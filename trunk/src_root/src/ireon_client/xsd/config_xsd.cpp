// Copyright (C) 2005-2006 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// In addition, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "config_xsd.h"

namespace ireon
{
  namespace client
  {
    // CPCConfig
    // 

    const CPCConfig::net::container& CPCConfig::
    net () const
    {
      return this->_xsd_net_;
    }

    CPCConfig::net::container& CPCConfig::
    net ()
    {
      return this->_xsd_net_;
    }

    void CPCConfig::
    net (const net::type& net)
    {
      this->_xsd_net_.set (net);
    }

    void CPCConfig::
    net (const net::container& net)
    {
      this->_xsd_net_ = net;
    }

    void CPCConfig::
    net (::std::auto_ptr< net::type > net)
    {
      this->_xsd_net_.set (net);
    }

    const CPCConfig::resources::container& CPCConfig::
    resources () const
    {
      return this->_xsd_resources_;
    }

    CPCConfig::resources::container& CPCConfig::
    resources ()
    {
      return this->_xsd_resources_;
    }

    void CPCConfig::
    resources (const resources::type& resources)
    {
      this->_xsd_resources_.set (resources);
    }

    void CPCConfig::
    resources (const resources::container& resources)
    {
      this->_xsd_resources_ = resources;
    }

    void CPCConfig::
    resources (::std::auto_ptr< resources::type > resources)
    {
      this->_xsd_resources_.set (resources);
    }

    const CPCConfig::world::container& CPCConfig::
    world () const
    {
      return this->_xsd_world_;
    }

    CPCConfig::world::container& CPCConfig::
    world ()
    {
      return this->_xsd_world_;
    }

    void CPCConfig::
    world (const world::type& world)
    {
      this->_xsd_world_.set (world);
    }

    void CPCConfig::
    world (const world::container& world)
    {
      this->_xsd_world_ = world;
    }

    void CPCConfig::
    world (::std::auto_ptr< world::type > world)
    {
      this->_xsd_world_.set (world);
    }

    const CPCConfig::profile::container& CPCConfig::
    profile () const
    {
      return this->_xsd_profile_;
    }

    CPCConfig::profile::container& CPCConfig::
    profile ()
    {
      return this->_xsd_profile_;
    }

    void CPCConfig::
    profile (const profile::type& profile)
    {
      this->_xsd_profile_.set (profile);
    }

    void CPCConfig::
    profile (const profile::container& profile)
    {
      this->_xsd_profile_ = profile;
    }

    void CPCConfig::
    profile (::std::auto_ptr< profile::type > profile)
    {
      this->_xsd_profile_.set (profile);
    }

    const CPCConfig::_interface::container& CPCConfig::
    _interface () const
    {
      return this->_xsd__interface_;
    }

    CPCConfig::_interface::container& CPCConfig::
    _interface ()
    {
      return this->_xsd__interface_;
    }

    void CPCConfig::
    _interface (const _interface::type& _interface)
    {
      this->_xsd__interface_.set (_interface);
    }

    void CPCConfig::
    _interface (const _interface::container& _interface)
    {
      this->_xsd__interface_ = _interface;
    }

    void CPCConfig::
    _interface (::std::auto_ptr< _interface::type > _interface)
    {
      this->_xsd__interface_.set (_interface);
    }


    // CNet
    // 

    const CNet::rootServer::container& CNet::
    rootServer () const
    {
      return this->_xsd_rootServer_;
    }

    CNet::rootServer::container& CNet::
    rootServer ()
    {
      return this->_xsd_rootServer_;
    }

    void CNet::
    rootServer (const rootServer::type& rootServer)
    {
      this->_xsd_rootServer_.set (rootServer);
    }

    void CNet::
    rootServer (const rootServer::container& rootServer)
    {
      this->_xsd_rootServer_ = rootServer;
    }

    void CNet::
    rootServer (::std::auto_ptr< rootServer::type > rootServer)
    {
      this->_xsd_rootServer_.set (rootServer);
    }

    const CNet::worldServer::container& CNet::
    worldServer () const
    {
      return this->_xsd_worldServer_;
    }

    CNet::worldServer::container& CNet::
    worldServer ()
    {
      return this->_xsd_worldServer_;
    }

    void CNet::
    worldServer (const worldServer::type& worldServer)
    {
      this->_xsd_worldServer_.set (worldServer);
    }

    void CNet::
    worldServer (const worldServer::container& worldServer)
    {
      this->_xsd_worldServer_ = worldServer;
    }

    void CNet::
    worldServer (::std::auto_ptr< worldServer::type > worldServer)
    {
      this->_xsd_worldServer_.set (worldServer);
    }


    // CRootServer
    // 

    const CRootServer::ip::type& CRootServer::ip::
    default_value ()
    {
      return default_value_;
    }

    const CRootServer::ip::container& CRootServer::
    ip () const
    {
      return this->_xsd_ip_;
    }

    CRootServer::ip::container& CRootServer::
    ip ()
    {
      return this->_xsd_ip_;
    }

    void CRootServer::
    ip (const ip::type& ip)
    {
      this->_xsd_ip_.set (ip);
    }

    void CRootServer::
    ip (const ip::container& ip)
    {
      this->_xsd_ip_ = ip;
    }

    void CRootServer::
    ip (::std::auto_ptr< ip::type > ip)
    {
      this->_xsd_ip_.set (ip);
    }

    const CRootServer::port::type& CRootServer::port::
    default_value ()
    {
      return default_value_;
    }

    const CRootServer::port::container& CRootServer::
    port () const
    {
      return this->_xsd_port_;
    }

    CRootServer::port::container& CRootServer::
    port ()
    {
      return this->_xsd_port_;
    }

    void CRootServer::
    port (const port::type& port)
    {
      this->_xsd_port_.set (port);
    }

    void CRootServer::
    port (const port::container& port)
    {
      this->_xsd_port_ = port;
    }

    void CRootServer::
    port (::std::auto_ptr< port::type > port)
    {
      this->_xsd_port_.set (port);
    }


    // CWorldServer
    // 

    const CWorldServer::port::type& CWorldServer::port::
    default_value ()
    {
      return default_value_;
    }

    const CWorldServer::port::container& CWorldServer::
    port () const
    {
      return this->_xsd_port_;
    }

    CWorldServer::port::container& CWorldServer::
    port ()
    {
      return this->_xsd_port_;
    }

    void CWorldServer::
    port (const port::type& port)
    {
      this->_xsd_port_.set (port);
    }

    void CWorldServer::
    port (const port::container& port)
    {
      this->_xsd_port_ = port;
    }

    void CWorldServer::
    port (::std::auto_ptr< port::type > port)
    {
      this->_xsd_port_.set (port);
    }


    // CIPv4Address
    // 


    // CPort
    // 


    // CWorldSettings
    // 

    const CWorldSettings::light::container& CWorldSettings::
    light () const
    {
      return this->_xsd_light_;
    }

    CWorldSettings::light::container& CWorldSettings::
    light ()
    {
      return this->_xsd_light_;
    }

    void CWorldSettings::
    light (const light::type& light)
    {
      this->_xsd_light_.set (light);
    }

    void CWorldSettings::
    light (const light::container& light)
    {
      this->_xsd_light_ = light;
    }

    void CWorldSettings::
    light (::std::auto_ptr< light::type > light)
    {
      this->_xsd_light_.set (light);
    }

    const CWorldSettings::worldPath::type& CWorldSettings::worldPath::
    default_value ()
    {
      return default_value_;
    }

    const CWorldSettings::worldPath::container& CWorldSettings::
    worldPath () const
    {
      return this->_xsd_worldPath_;
    }

    CWorldSettings::worldPath::container& CWorldSettings::
    worldPath ()
    {
      return this->_xsd_worldPath_;
    }

    void CWorldSettings::
    worldPath (const worldPath::type& worldPath)
    {
      this->_xsd_worldPath_.set (worldPath);
    }

    void CWorldSettings::
    worldPath (const worldPath::container& worldPath)
    {
      this->_xsd_worldPath_ = worldPath;
    }

    void CWorldSettings::
    worldPath (::std::auto_ptr< worldPath::type > worldPath)
    {
      this->_xsd_worldPath_.set (worldPath);
    }

    const CWorldSettings::proto::container& CWorldSettings::
    proto () const
    {
      return this->_xsd_proto_;
    }

    CWorldSettings::proto::container& CWorldSettings::
    proto ()
    {
      return this->_xsd_proto_;
    }

    void CWorldSettings::
    proto (const proto::type& proto)
    {
      this->_xsd_proto_.set (proto);
    }

    void CWorldSettings::
    proto (const proto::container& proto)
    {
      this->_xsd_proto_ = proto;
    }

    void CWorldSettings::
    proto (::std::auto_ptr< proto::type > proto)
    {
      this->_xsd_proto_.set (proto);
    }

    const CWorldSettings::dataPath::type& CWorldSettings::dataPath::
    default_value ()
    {
      return default_value_;
    }

    const CWorldSettings::dataPath::container& CWorldSettings::
    dataPath () const
    {
      return this->_xsd_dataPath_;
    }

    CWorldSettings::dataPath::container& CWorldSettings::
    dataPath ()
    {
      return this->_xsd_dataPath_;
    }

    void CWorldSettings::
    dataPath (const dataPath::type& dataPath)
    {
      this->_xsd_dataPath_.set (dataPath);
    }

    void CWorldSettings::
    dataPath (const dataPath::container& dataPath)
    {
      this->_xsd_dataPath_ = dataPath;
    }

    void CWorldSettings::
    dataPath (::std::auto_ptr< dataPath::type > dataPath)
    {
      this->_xsd_dataPath_.set (dataPath);
    }

    const CWorldSettings::player::container& CWorldSettings::
    player () const
    {
      return this->_xsd_player_;
    }

    CWorldSettings::player::container& CWorldSettings::
    player ()
    {
      return this->_xsd_player_;
    }

    void CWorldSettings::
    player (const player::type& player)
    {
      this->_xsd_player_.set (player);
    }

    void CWorldSettings::
    player (const player::container& player)
    {
      this->_xsd_player_ = player;
    }

    void CWorldSettings::
    player (::std::auto_ptr< player::type > player)
    {
      this->_xsd_player_.set (player);
    }


    // CProtoSettings
    // 

    const CProtoSettings::directory::type& CProtoSettings::directory::
    default_value ()
    {
      return default_value_;
    }

    const CProtoSettings::directory::container& CProtoSettings::
    directory () const
    {
      return this->_xsd_directory_;
    }

    CProtoSettings::directory::container& CProtoSettings::
    directory ()
    {
      return this->_xsd_directory_;
    }

    void CProtoSettings::
    directory (const directory::type& directory)
    {
      this->_xsd_directory_.set (directory);
    }

    void CProtoSettings::
    directory (const directory::container& directory)
    {
      this->_xsd_directory_ = directory;
    }

    void CProtoSettings::
    directory (::std::auto_ptr< directory::type > directory)
    {
      this->_xsd_directory_.set (directory);
    }

    const CProtoSettings::loadAll::type& CProtoSettings::loadAll::
    default_value ()
    {
      return default_value_;
    }

    const CProtoSettings::loadAll::container& CProtoSettings::
    loadAll () const
    {
      return this->_xsd_loadAll_;
    }

    CProtoSettings::loadAll::container& CProtoSettings::
    loadAll ()
    {
      return this->_xsd_loadAll_;
    }

    void CProtoSettings::
    loadAll (const loadAll::type& loadAll)
    {
      this->_xsd_loadAll_.set (loadAll);
    }

    void CProtoSettings::
    loadAll (const loadAll::container& loadAll)
    {
      this->_xsd_loadAll_ = loadAll;
    }


    // CPlayerSettings
    // 

    const CPlayerSettings::mesh::type& CPlayerSettings::mesh::
    default_value ()
    {
      return default_value_;
    }

    const CPlayerSettings::mesh::container& CPlayerSettings::
    mesh () const
    {
      return this->_xsd_mesh_;
    }

    CPlayerSettings::mesh::container& CPlayerSettings::
    mesh ()
    {
      return this->_xsd_mesh_;
    }

    void CPlayerSettings::
    mesh (const mesh::type& mesh)
    {
      this->_xsd_mesh_.set (mesh);
    }

    void CPlayerSettings::
    mesh (const mesh::container& mesh)
    {
      this->_xsd_mesh_ = mesh;
    }

    void CPlayerSettings::
    mesh (::std::auto_ptr< mesh::type > mesh)
    {
      this->_xsd_mesh_.set (mesh);
    }


    // CLightSettings
    // 

    const CLightSettings::main::type& CLightSettings::main::
    default_value ()
    {
      return default_value_;
    }

    const CLightSettings::main::type& CLightSettings::
    main () const
    {
      return this->_xsd_main_.get ();
    }

    CLightSettings::main::type& CLightSettings::
    main ()
    {
      return this->_xsd_main_.get ();
    }

    void CLightSettings::
    main (const main::type& main)
    {
      this->_xsd_main_.set (main);
    }

    void CLightSettings::
    main (::std::auto_ptr< main::type > main)
    {
      this->_xsd_main_.set (main);
    }

    const CLightSettings::ambient::type& CLightSettings::ambient::
    default_value ()
    {
      return default_value_;
    }

    const CLightSettings::ambient::type& CLightSettings::
    ambient () const
    {
      return this->_xsd_ambient_.get ();
    }

    CLightSettings::ambient::type& CLightSettings::
    ambient ()
    {
      return this->_xsd_ambient_.get ();
    }

    void CLightSettings::
    ambient (const ambient::type& ambient)
    {
      this->_xsd_ambient_.set (ambient);
    }

    void CLightSettings::
    ambient (::std::auto_ptr< ambient::type > ambient)
    {
      this->_xsd_ambient_.set (ambient);
    }

    const CLightSettings::shadows::container& CLightSettings::
    shadows () const
    {
      return this->_xsd_shadows_;
    }

    CLightSettings::shadows::container& CLightSettings::
    shadows ()
    {
      return this->_xsd_shadows_;
    }

    void CLightSettings::
    shadows (const shadows::type& shadows)
    {
      this->_xsd_shadows_.set (shadows);
    }

    void CLightSettings::
    shadows (const shadows::container& shadows)
    {
      this->_xsd_shadows_ = shadows;
    }

    void CLightSettings::
    shadows (::std::auto_ptr< shadows::type > shadows)
    {
      this->_xsd_shadows_.set (shadows);
    }

    const CLightSettings::enabled::type& CLightSettings::enabled::
    default_value ()
    {
      return default_value_;
    }

    const CLightSettings::enabled::type& CLightSettings::
    enabled () const
    {
      return this->_xsd_enabled_.get ();
    }

    CLightSettings::enabled::type& CLightSettings::
    enabled ()
    {
      return this->_xsd_enabled_.get ();
    }

    void CLightSettings::
    enabled (const enabled::type& enabled)
    {
      this->_xsd_enabled_.set (enabled);
    }


    // CShadowSettings
    // 

    const CShadowSettings::colour::type& CShadowSettings::colour::
    default_value ()
    {
      return default_value_;
    }

    const CShadowSettings::colour::type& CShadowSettings::
    colour () const
    {
      return this->_xsd_colour_.get ();
    }

    CShadowSettings::colour::type& CShadowSettings::
    colour ()
    {
      return this->_xsd_colour_.get ();
    }

    void CShadowSettings::
    colour (const colour::type& colour)
    {
      this->_xsd_colour_.set (colour);
    }

    void CShadowSettings::
    colour (::std::auto_ptr< colour::type > colour)
    {
      this->_xsd_colour_.set (colour);
    }

    const CShadowSettings::enabled::type& CShadowSettings::enabled::
    default_value ()
    {
      return default_value_;
    }

    const CShadowSettings::enabled::type& CShadowSettings::
    enabled () const
    {
      return this->_xsd_enabled_.get ();
    }

    CShadowSettings::enabled::type& CShadowSettings::
    enabled ()
    {
      return this->_xsd_enabled_.get ();
    }

    void CShadowSettings::
    enabled (const enabled::type& enabled)
    {
      this->_xsd_enabled_.set (enabled);
    }


    // CProfile
    // 

    const CProfile::login::type& CProfile::
    login () const
    {
      return this->_xsd_login_.get ();
    }

    CProfile::login::type& CProfile::
    login ()
    {
      return this->_xsd_login_.get ();
    }

    void CProfile::
    login (const login::type& login)
    {
      this->_xsd_login_.set (login);
    }

    void CProfile::
    login (::std::auto_ptr< login::type > login)
    {
      this->_xsd_login_.set (login);
    }

    const CProfile::password::type& CProfile::
    password () const
    {
      return this->_xsd_password_.get ();
    }

    CProfile::password::type& CProfile::
    password ()
    {
      return this->_xsd_password_.get ();
    }

    void CProfile::
    password (const password::type& password)
    {
      this->_xsd_password_.set (password);
    }

    void CProfile::
    password (::std::auto_ptr< password::type > password)
    {
      this->_xsd_password_.set (password);
    }

    const CProfile::registration::type& CProfile::registration::
    default_value ()
    {
      return default_value_;
    }

    const CProfile::registration::container& CProfile::
    registration () const
    {
      return this->_xsd_registration_;
    }

    CProfile::registration::container& CProfile::
    registration ()
    {
      return this->_xsd_registration_;
    }

    void CProfile::
    registration (const registration::type& registration)
    {
      this->_xsd_registration_.set (registration);
    }

    void CProfile::
    registration (const registration::container& registration)
    {
      this->_xsd_registration_ = registration;
    }


    // CInterfaceSettings
    // 

    const CInterfaceSettings::dir::type& CInterfaceSettings::dir::
    default_value ()
    {
      return default_value_;
    }

    const CInterfaceSettings::dir::container& CInterfaceSettings::
    dir () const
    {
      return this->_xsd_dir_;
    }

    CInterfaceSettings::dir::container& CInterfaceSettings::
    dir ()
    {
      return this->_xsd_dir_;
    }

    void CInterfaceSettings::
    dir (const dir::type& dir)
    {
      this->_xsd_dir_.set (dir);
    }

    void CInterfaceSettings::
    dir (const dir::container& dir)
    {
      this->_xsd_dir_ = dir;
    }

    void CInterfaceSettings::
    dir (::std::auto_ptr< dir::type > dir)
    {
      this->_xsd_dir_.set (dir);
    }

    const CInterfaceSettings::symbols::type& CInterfaceSettings::symbols::
    default_value ()
    {
      return default_value_;
    }

    const CInterfaceSettings::symbols::container& CInterfaceSettings::
    symbols () const
    {
      return this->_xsd_symbols_;
    }

    CInterfaceSettings::symbols::container& CInterfaceSettings::
    symbols ()
    {
      return this->_xsd_symbols_;
    }

    void CInterfaceSettings::
    symbols (const symbols::type& symbols)
    {
      this->_xsd_symbols_.set (symbols);
    }

    void CInterfaceSettings::
    symbols (const symbols::container& symbols)
    {
      this->_xsd_symbols_ = symbols;
    }

    void CInterfaceSettings::
    symbols (::std::auto_ptr< symbols::type > symbols)
    {
      this->_xsd_symbols_.set (symbols);
    }

    const CInterfaceSettings::script::container& CInterfaceSettings::
    script () const
    {
      return this->_xsd_script_;
    }

    CInterfaceSettings::script::container& CInterfaceSettings::
    script ()
    {
      return this->_xsd_script_;
    }

    void CInterfaceSettings::
    script (const script::container& script)
    {
      this->_xsd_script_ = script;
    }


    // CResources
    // 

    const CResources::resource::container& CResources::
    resource () const
    {
      return this->_xsd_resource_;
    }

    CResources::resource::container& CResources::
    resource ()
    {
      return this->_xsd_resource_;
    }

    void CResources::
    resource (const resource::container& resource)
    {
      this->_xsd_resource_ = resource;
    }


    // CResourceItem
    // 

    const CResourceItem::category::type& CResourceItem::
    category () const
    {
      return this->_xsd_category_.get ();
    }

    CResourceItem::category::type& CResourceItem::
    category ()
    {
      return this->_xsd_category_.get ();
    }

    void CResourceItem::
    category (const category::type& category)
    {
      this->_xsd_category_.set (category);
    }

    void CResourceItem::
    category (::std::auto_ptr< category::type > category)
    {
      this->_xsd_category_.set (category);
    }

    const CResourceItem::type::type_& CResourceItem::
    type () const
    {
      return this->_xsd_type_.get ();
    }

    CResourceItem::type::type_& CResourceItem::
    type ()
    {
      return this->_xsd_type_.get ();
    }

    void CResourceItem::
    type (const type::type_& type)
    {
      this->_xsd_type_.set (type);
    }

    void CResourceItem::
    type (::std::auto_ptr< type::type_ > type)
    {
      this->_xsd_type_.set (type);
    }
  }
}

#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/parser.hxx>

namespace ireon
{
  namespace client
  {
    // CPCConfig
    //

    CPCConfig::
    CPCConfig ()
    : ::xml_schema::type (),
    _xsd_net_ (::xml_schema::flags (), this),
    _xsd_resources_ (::xml_schema::flags (), this),
    _xsd_world_ (::xml_schema::flags (), this),
    _xsd_profile_ (::xml_schema::flags (), this),
    _xsd__interface_ (::xml_schema::flags (), this)
    {
    }

    CPCConfig::
    CPCConfig (const CPCConfig& _xsd_CPCConfig,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CPCConfig, f, c),
    _xsd_net_ (_xsd_CPCConfig._xsd_net_,
               f | ::xml_schema::flags::not_root,
               this),
    _xsd_resources_ (_xsd_CPCConfig._xsd_resources_,
                     f | ::xml_schema::flags::not_root,
                     this),
    _xsd_world_ (_xsd_CPCConfig._xsd_world_,
                 f | ::xml_schema::flags::not_root,
                 this),
    _xsd_profile_ (_xsd_CPCConfig._xsd_profile_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd__interface_ (_xsd_CPCConfig._xsd__interface_,
                      f | ::xml_schema::flags::not_root,
                      this)
    {
    }

    CPCConfig::
    CPCConfig (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_net_ (f | ::xml_schema::flags::not_root, this),
    _xsd_resources_ (f | ::xml_schema::flags::not_root, this),
    _xsd_world_ (f | ::xml_schema::flags::not_root, this),
    _xsd_profile_ (f | ::xml_schema::flags::not_root, this),
    _xsd__interface_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CPCConfig::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // net
        //
        {
          if (e.name () == "net" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< net::type > r (
              net::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->net ())
              continue;
            this->net (r);
            continue;
          }
        }

        // resources
        //
        {
          if (e.name () == "resources" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< resources::type > r (
              resources::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->resources ())
              continue;
            this->resources (r);
            continue;
          }
        }

        // world
        //
        {
          if (e.name () == "world" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< world::type > r (
              world::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->world ())
              continue;
            this->world (r);
            continue;
          }
        }

        // profile
        //
        {
          if (e.name () == "profile" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< profile::type > r (
              profile::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->profile ())
              continue;
            this->profile (r);
            continue;
          }
        }

        // _interface
        //
        {
          if (e.name () == "_interface" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< _interface::type > r (
              _interface::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->_interface ())
              continue;
            this->_interface (r);
            continue;
          }
        }
      }
    }

    CPCConfig* CPCConfig::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CPCConfig (*this, f, c);
    }

    // CNet
    //

    CNet::
    CNet ()
    : ::xml_schema::type (),
    _xsd_rootServer_ (::xml_schema::flags (), this),
    _xsd_worldServer_ (::xml_schema::flags (), this)
    {
    }

    CNet::
    CNet (const CNet& _xsd_CNet,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CNet, f, c),
    _xsd_rootServer_ (_xsd_CNet._xsd_rootServer_,
                      f | ::xml_schema::flags::not_root,
                      this),
    _xsd_worldServer_ (_xsd_CNet._xsd_worldServer_,
                       f | ::xml_schema::flags::not_root,
                       this)
    {
    }

    CNet::
    CNet (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_rootServer_ (f | ::xml_schema::flags::not_root, this),
    _xsd_worldServer_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CNet::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // rootServer
        //
        {
          if (e.name () == "rootServer" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< rootServer::type > r (
              rootServer::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->rootServer ())
              continue;
            this->rootServer (r);
            continue;
          }
        }

        // worldServer
        //
        {
          if (e.name () == "worldServer" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< worldServer::type > r (
              worldServer::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->worldServer ())
              continue;
            this->worldServer (r);
            continue;
          }
        }
      }
    }

    CNet* CNet::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CNet (*this, f, c);
    }

    // CRootServer
    //

    // CRootServer::ip
    // 

    const CRootServer::ip::type CRootServer::ip::default_value_ (
      ::std::basic_string< char > ("127.0.0.1"), 0, 0, 0);

    // CRootServer::port
    // 

    const CRootServer::port::type CRootServer::port::default_value_ (
      ::std::basic_string< char > ("29100"), 0, 0, 0);

    CRootServer::
    CRootServer ()
    : ::xml_schema::type (),
    _xsd_ip_ (::xml_schema::flags (), this),
    _xsd_port_ (::xml_schema::flags (), this)
    {
    }

    CRootServer::
    CRootServer (const CRootServer& _xsd_CRootServer,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CRootServer, f, c),
    _xsd_ip_ (_xsd_CRootServer._xsd_ip_,
              f | ::xml_schema::flags::not_root,
              this),
    _xsd_port_ (_xsd_CRootServer._xsd_port_,
                f | ::xml_schema::flags::not_root,
                this)
    {
    }

    CRootServer::
    CRootServer (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_ip_ (f | ::xml_schema::flags::not_root, this),
    _xsd_port_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CRootServer::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // ip
        //
        {
          if (e.name () == "ip" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< ip::type > r (
              ip::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->ip ())
              continue;
            this->ip (r);
            continue;
          }
        }

        // port
        //
        {
          if (e.name () == "port" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< port::type > r (
              port::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->port ())
              continue;
            this->port (r);
            continue;
          }
        }
      }
    }

    CRootServer* CRootServer::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CRootServer (*this, f, c);
    }

    // CWorldServer
    //

    // CWorldServer::port
    // 

    const CWorldServer::port::type CWorldServer::port::default_value_ (
      ::std::basic_string< char > ("29120"), 0, 0, 0);

    CWorldServer::
    CWorldServer ()
    : ::xml_schema::type (),
    _xsd_port_ (::xml_schema::flags (), this)
    {
    }

    CWorldServer::
    CWorldServer (const CWorldServer& _xsd_CWorldServer,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CWorldServer, f, c),
    _xsd_port_ (_xsd_CWorldServer._xsd_port_,
                f | ::xml_schema::flags::not_root,
                this)
    {
    }

    CWorldServer::
    CWorldServer (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_port_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CWorldServer::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // port
        //
        {
          if (e.name () == "port" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< port::type > r (
              port::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->port ())
              continue;
            this->port (r);
            continue;
          }
        }
      }
    }

    CWorldServer* CWorldServer::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CWorldServer (*this, f, c);
    }

    // CIPv4Address
    //

    CIPv4Address::
    CIPv4Address (const _xsd_CIPv4Address::base_& _xsd_CIPv4Address)
    : ::xml_schema::string (_xsd_CIPv4Address)
    {
    }

    CIPv4Address::
    CIPv4Address (const CIPv4Address& _xsd_CIPv4Address,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (_xsd_CIPv4Address, f, c)
    {
    }

    CIPv4Address::
    CIPv4Address (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    CIPv4Address::
    CIPv4Address (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    CIPv4Address::
    CIPv4Address (const ::std::basic_string< char >& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    CIPv4Address* CIPv4Address::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CIPv4Address (*this, f, c);
    }

    // CPort
    //

    CPort::
    CPort (const _xsd_CPort::base_& _xsd_CPort)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (_xsd_CPort)
    {
    }

    CPort::
    CPort (const CPort& _xsd_CPort,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (_xsd_CPort, f, c)
    {
    }

    CPort::
    CPort (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    CPort::
    CPort (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    CPort::
    CPort (const ::std::basic_string< char >& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    CPort* CPort::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CPort (*this, f, c);
    }

    // CWorldSettings
    //

    // CWorldSettings::worldPath
    // 

    const CWorldSettings::worldPath::type CWorldSettings::worldPath::default_value_ (
      ::std::basic_string< char > ("../data/landscape/world.cfg"), 0, 0, 0);

    // CWorldSettings::dataPath
    // 

    const CWorldSettings::dataPath::type CWorldSettings::dataPath::default_value_ (
      ::std::basic_string< char > ("../data/"), 0, 0, 0);

    CWorldSettings::
    CWorldSettings ()
    : ::xml_schema::type (),
    _xsd_light_ (::xml_schema::flags (), this),
    _xsd_worldPath_ (::xml_schema::flags (), this),
    _xsd_proto_ (::xml_schema::flags (), this),
    _xsd_dataPath_ (::xml_schema::flags (), this),
    _xsd_player_ (::xml_schema::flags (), this)
    {
    }

    CWorldSettings::
    CWorldSettings (const CWorldSettings& _xsd_CWorldSettings,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CWorldSettings, f, c),
    _xsd_light_ (_xsd_CWorldSettings._xsd_light_,
                 f | ::xml_schema::flags::not_root,
                 this),
    _xsd_worldPath_ (_xsd_CWorldSettings._xsd_worldPath_,
                     f | ::xml_schema::flags::not_root,
                     this),
    _xsd_proto_ (_xsd_CWorldSettings._xsd_proto_,
                 f | ::xml_schema::flags::not_root,
                 this),
    _xsd_dataPath_ (_xsd_CWorldSettings._xsd_dataPath_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_player_ (_xsd_CWorldSettings._xsd_player_,
                  f | ::xml_schema::flags::not_root,
                  this)
    {
    }

    CWorldSettings::
    CWorldSettings (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_light_ (f | ::xml_schema::flags::not_root, this),
    _xsd_worldPath_ (f | ::xml_schema::flags::not_root, this),
    _xsd_proto_ (f | ::xml_schema::flags::not_root, this),
    _xsd_dataPath_ (f | ::xml_schema::flags::not_root, this),
    _xsd_player_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CWorldSettings::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // light
        //
        {
          if (e.name () == "light" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< light::type > r (
              light::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->light ())
              continue;
            this->light (r);
            continue;
          }
        }

        // worldPath
        //
        {
          if (e.name () == "worldPath" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< worldPath::type > r (
              worldPath::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->worldPath ())
              continue;
            this->worldPath (r);
            continue;
          }
        }

        // proto
        //
        {
          if (e.name () == "proto" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< proto::type > r (
              proto::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->proto ())
              continue;
            this->proto (r);
            continue;
          }
        }

        // dataPath
        //
        {
          if (e.name () == "dataPath" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< dataPath::type > r (
              dataPath::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->dataPath ())
              continue;
            this->dataPath (r);
            continue;
          }
        }

        // player
        //
        {
          if (e.name () == "player" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< player::type > r (
              player::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->player ())
              continue;
            this->player (r);
            continue;
          }
        }
      }
    }

    CWorldSettings* CWorldSettings::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CWorldSettings (*this, f, c);
    }

    // CProtoSettings
    //

    // CProtoSettings::directory
    // 

    const CProtoSettings::directory::type CProtoSettings::directory::default_value_ (
      ::std::basic_string< char > ("../data/proto/"), 0, 0, 0);

    // CProtoSettings::loadAll
    // 

    const CProtoSettings::loadAll::type CProtoSettings::loadAll::default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::basic_string< char > ("true"), 0, 0, 0));

    CProtoSettings::
    CProtoSettings ()
    : ::xml_schema::type (),
    _xsd_directory_ (::xml_schema::flags (), this),
    _xsd_loadAll_ (::xml_schema::flags (), this)
    {
    }

    CProtoSettings::
    CProtoSettings (const CProtoSettings& _xsd_CProtoSettings,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CProtoSettings, f, c),
    _xsd_directory_ (_xsd_CProtoSettings._xsd_directory_,
                     f | ::xml_schema::flags::not_root,
                     this),
    _xsd_loadAll_ (_xsd_CProtoSettings._xsd_loadAll_,
                   f | ::xml_schema::flags::not_root,
                   this)
    {
    }

    CProtoSettings::
    CProtoSettings (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_directory_ (f | ::xml_schema::flags::not_root, this),
    _xsd_loadAll_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CProtoSettings::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // directory
        //
        {
          if (e.name () == "directory" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< directory::type > r (
              directory::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->directory ())
              continue;
            this->directory (r);
            continue;
          }
        }

        // loadAll
        //
        {
          if (e.name () == "loadAll" && e.namespace_ ().empty ())
          {
            if (this->loadAll ())
              continue;
            this->loadAll (
              loadAll::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }
        }
      }
    }

    CProtoSettings* CProtoSettings::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CProtoSettings (*this, f, c);
    }

    // CPlayerSettings
    //

    // CPlayerSettings::mesh
    // 

    const CPlayerSettings::mesh::type CPlayerSettings::mesh::default_value_ (
      ::std::basic_string< char > ("ninja.mesh"), 0, 0, 0);

    CPlayerSettings::
    CPlayerSettings ()
    : ::xml_schema::type (),
    _xsd_mesh_ (::xml_schema::flags (), this)
    {
    }

    CPlayerSettings::
    CPlayerSettings (const CPlayerSettings& _xsd_CPlayerSettings,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CPlayerSettings, f, c),
    _xsd_mesh_ (_xsd_CPlayerSettings._xsd_mesh_,
                f | ::xml_schema::flags::not_root,
                this)
    {
    }

    CPlayerSettings::
    CPlayerSettings (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_mesh_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CPlayerSettings::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // mesh
        //
        {
          if (e.name () == "mesh" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< mesh::type > r (
              mesh::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->mesh ())
              continue;
            this->mesh (r);
            continue;
          }
        }
      }
    }

    CPlayerSettings* CPlayerSettings::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CPlayerSettings (*this, f, c);
    }

    // CLightSettings
    //

    // CLightSettings::main
    // 

    const CLightSettings::main::type CLightSettings::main::default_value_ (
      ::std::basic_string< char > ("0.2 0.18 0.2"), 0, 0, 0);

    // CLightSettings::ambient
    // 

    const CLightSettings::ambient::type CLightSettings::ambient::default_value_ (
      ::std::basic_string< char > ("0.5 0.5 0.5 1"), 0, 0, 0);

    // CLightSettings::enabled
    // 

    const CLightSettings::enabled::type CLightSettings::enabled::default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::basic_string< char > ("true"), 0, 0, 0));

    CLightSettings::
    CLightSettings (const main::type& _xsd_main,
                    const ambient::type& _xsd_ambient)
    : ::xml_schema::type (),
    _xsd_main_ (_xsd_main,
                ::xml_schema::flags (),
                this),
    _xsd_ambient_ (_xsd_ambient,
                   ::xml_schema::flags (),
                   this),
    _xsd_shadows_ (::xml_schema::flags (), this),
    _xsd_enabled_ (enabled::default_value (),
                   ::xml_schema::flags (),
                   this)
    {
    }

    CLightSettings::
    CLightSettings (const CLightSettings& _xsd_CLightSettings,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CLightSettings, f, c),
    _xsd_main_ (_xsd_CLightSettings._xsd_main_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_ambient_ (_xsd_CLightSettings._xsd_ambient_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd_shadows_ (_xsd_CLightSettings._xsd_shadows_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd_enabled_ (_xsd_CLightSettings._xsd_enabled_,
                   f | ::xml_schema::flags::not_root,
                   this)
    {
    }

    CLightSettings::
    CLightSettings (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_main_ (f | ::xml_schema::flags::not_root, this),
    _xsd_ambient_ (f | ::xml_schema::flags::not_root, this),
    _xsd_shadows_ (f | ::xml_schema::flags::not_root, this),
    _xsd_enabled_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CLightSettings::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // main
        //
        {
          if (e.name () == "main" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< main::type > r (
              main::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_main_.present ())
              continue;
            this->main (r);
            continue;
          }
        }

        // ambient
        //
        {
          if (e.name () == "ambient" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< ambient::type > r (
              ambient::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_ambient_.present ())
              continue;
            this->ambient (r);
            continue;
          }
        }

        // shadows
        //
        {
          if (e.name () == "shadows" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< shadows::type > r (
              shadows::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->shadows ())
              continue;
            this->shadows (r);
            continue;
          }
        }
      }

      if (!_xsd_main_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "main",
          "");
      }

      if (!_xsd_ambient_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ambient",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "enabled" && a.namespace_ ().empty ())
        {
          this->enabled (
            enabled::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }
      }

      if (!_xsd_enabled_.present ())
      {
        this->enabled (
          enabled::traits::create (
            ::std::basic_string< char > ("true"),
            &e,
            f | ::xml_schema::flags::not_root,
            this));
      }
    }

    CLightSettings* CLightSettings::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CLightSettings (*this, f, c);
    }

    // CShadowSettings
    //

    // CShadowSettings::colour
    // 

    const CShadowSettings::colour::type CShadowSettings::colour::default_value_ (
      ::std::basic_string< char > ("0.5 0.5 0.5"), 0, 0, 0);

    // CShadowSettings::enabled
    // 

    const CShadowSettings::enabled::type CShadowSettings::enabled::default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::basic_string< char > ("true"), 0, 0, 0));

    CShadowSettings::
    CShadowSettings (const colour::type& _xsd_colour)
    : ::xml_schema::type (),
    _xsd_colour_ (_xsd_colour,
                  ::xml_schema::flags (),
                  this),
    _xsd_enabled_ (enabled::default_value (),
                   ::xml_schema::flags (),
                   this)
    {
    }

    CShadowSettings::
    CShadowSettings (const CShadowSettings& _xsd_CShadowSettings,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CShadowSettings, f, c),
    _xsd_colour_ (_xsd_CShadowSettings._xsd_colour_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_enabled_ (_xsd_CShadowSettings._xsd_enabled_,
                   f | ::xml_schema::flags::not_root,
                   this)
    {
    }

    CShadowSettings::
    CShadowSettings (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_colour_ (f | ::xml_schema::flags::not_root, this),
    _xsd_enabled_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CShadowSettings::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // colour
        //
        {
          if (e.name () == "colour" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< colour::type > r (
              colour::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_colour_.present ())
              continue;
            this->colour (r);
            continue;
          }
        }
      }

      if (!_xsd_colour_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "colour",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "enabled" && a.namespace_ ().empty ())
        {
          this->enabled (
            enabled::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }
      }

      if (!_xsd_enabled_.present ())
      {
        this->enabled (
          enabled::traits::create (
            ::std::basic_string< char > ("true"),
            &e,
            f | ::xml_schema::flags::not_root,
            this));
      }
    }

    CShadowSettings* CShadowSettings::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CShadowSettings (*this, f, c);
    }

    // CProfile
    //

    // CProfile::registration
    // 

    const CProfile::registration::type CProfile::registration::default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
        ::std::basic_string< char > ("true"), 0, 0, 0));

    CProfile::
    CProfile (const login::type& _xsd_login,
              const password::type& _xsd_password)
    : ::xml_schema::type (),
    _xsd_login_ (_xsd_login,
                 ::xml_schema::flags (),
                 this),
    _xsd_password_ (_xsd_password,
                    ::xml_schema::flags (),
                    this),
    _xsd_registration_ (::xml_schema::flags (), this)
    {
    }

    CProfile::
    CProfile (const CProfile& _xsd_CProfile,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CProfile, f, c),
    _xsd_login_ (_xsd_CProfile._xsd_login_,
                 f | ::xml_schema::flags::not_root,
                 this),
    _xsd_password_ (_xsd_CProfile._xsd_password_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_registration_ (_xsd_CProfile._xsd_registration_,
                        f | ::xml_schema::flags::not_root,
                        this)
    {
    }

    CProfile::
    CProfile (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_login_ (f | ::xml_schema::flags::not_root, this),
    _xsd_password_ (f | ::xml_schema::flags::not_root, this),
    _xsd_registration_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CProfile::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // login
        //
        {
          if (e.name () == "login" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< login::type > r (
              login::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_login_.present ())
              continue;
            this->login (r);
            continue;
          }
        }

        // password
        //
        {
          if (e.name () == "password" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< password::type > r (
              password::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_password_.present ())
              continue;
            this->password (r);
            continue;
          }
        }

        // registration
        //
        {
          if (e.name () == "registration" && e.namespace_ ().empty ())
          {
            if (this->registration ())
              continue;
            this->registration (
              registration::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }
        }
      }

      if (!_xsd_login_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "login",
          "");
      }

      if (!_xsd_password_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "password",
          "");
      }
    }

    CProfile* CProfile::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CProfile (*this, f, c);
    }

    // CInterfaceSettings
    //

    // CInterfaceSettings::dir
    // 

    const CInterfaceSettings::dir::type CInterfaceSettings::dir::default_value_ (
      ::std::basic_string< char > ("../data/interface"), 0, 0, 0);

    // CInterfaceSettings::symbols
    // 

    const CInterfaceSettings::symbols::type CInterfaceSettings::symbols::default_value_ (
      ::std::basic_string< char > ("str"), 0, 0, 0);

    CInterfaceSettings::
    CInterfaceSettings ()
    : ::xml_schema::type (),
    _xsd_dir_ (::xml_schema::flags (), this),
    _xsd_symbols_ (::xml_schema::flags (), this),
    _xsd_script_ (::xml_schema::flags (), this)
    {
    }

    CInterfaceSettings::
    CInterfaceSettings (const CInterfaceSettings& _xsd_CInterfaceSettings,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CInterfaceSettings, f, c),
    _xsd_dir_ (_xsd_CInterfaceSettings._xsd_dir_,
               f | ::xml_schema::flags::not_root,
               this),
    _xsd_symbols_ (_xsd_CInterfaceSettings._xsd_symbols_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd_script_ (_xsd_CInterfaceSettings._xsd_script_,
                  f | ::xml_schema::flags::not_root,
                  this)
    {
    }

    CInterfaceSettings::
    CInterfaceSettings (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_dir_ (f | ::xml_schema::flags::not_root, this),
    _xsd_symbols_ (f | ::xml_schema::flags::not_root, this),
    _xsd_script_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CInterfaceSettings::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // dir
        //
        {
          if (e.name () == "dir" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< dir::type > r (
              dir::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->dir ())
              continue;
            this->dir (r);
            continue;
          }
        }

        // symbols
        //
        {
          if (e.name () == "symbols" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< symbols::type > r (
              symbols::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->symbols ())
              continue;
            this->symbols (r);
            continue;
          }
        }

        // script
        //
        {
          if (e.name () == "script" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< script::type > r (
              script::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            this->script ().push_back (r);
            continue;
          }
        }
      }
    }

    CInterfaceSettings* CInterfaceSettings::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CInterfaceSettings (*this, f, c);
    }

    // CResources
    //

    CResources::
    CResources ()
    : ::xml_schema::type (),
    _xsd_resource_ (::xml_schema::flags (), this)
    {
    }

    CResources::
    CResources (const CResources& _xsd_CResources,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CResources, f, c),
    _xsd_resource_ (_xsd_CResources._xsd_resource_,
                    f | ::xml_schema::flags::not_root,
                    this)
    {
    }

    CResources::
    CResources (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_resource_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CResources::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // resource
        //
        {
          if (e.name () == "resource" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< resource::type > r (
              resource::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            this->resource ().push_back (r);
            continue;
          }
        }
      }
    }

    CResources* CResources::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CResources (*this, f, c);
    }

    // CResourceItem
    //

    CResourceItem::
    CResourceItem (const _xsd_CResourceItem::base_& _xsd_CResourceItem,
                   const category::type& _xsd_category,
                   const type::type_& _xsd_type)
    : ::xml_schema::string (_xsd_CResourceItem),
    _xsd_category_ (_xsd_category,
                    ::xml_schema::flags (),
                    this),
    _xsd_type_ (_xsd_type,
                ::xml_schema::flags (),
                this)
    {
    }

    CResourceItem::
    CResourceItem (const CResourceItem& _xsd_CResourceItem,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::string (_xsd_CResourceItem, f, c),
    _xsd_category_ (_xsd_CResourceItem._xsd_category_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_type_ (_xsd_CResourceItem._xsd_type_,
                f | ::xml_schema::flags::not_root,
                this)
    {
    }

    CResourceItem::
    CResourceItem (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c),
    _xsd_category_ (f | ::xml_schema::flags::not_root, this),
    _xsd_type_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CResourceItem::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "category" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< category::type > r (
            category::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->category (r);
          continue;
        }

        if (a.name () == "type" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< type::type_ > r (
            type::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->type (r);
          continue;
        }
      }

      if (!_xsd_category_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "category",
          "");
      }

      if (!_xsd_type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    CResourceItem* CResourceItem::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CResourceItem (*this, f, c);
    }
  }
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace ireon
{
  namespace client
  {
    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (const ::std::basic_string< char >& u,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::ireon::client::config (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (const ::std::basic_string< char >& u,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< char > ();
      }

      return ::ireon::client::config (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (const ::std::basic_string< char >& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< char > ();
      }

      return ::ireon::client::config (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (::std::istream& is,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::ireon::client::config (wrap, f, p);
    }

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (::std::istream& is,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::ireon::client::config (wrap, h, f, p);
    }

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::ireon::client::config (wrap, h, f, p);
    }

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (::std::istream& is,
            const ::std::basic_string< char >& sid,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::ireon::client::config (wrap, f, p);
    }

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (::std::istream& is,
            const ::std::basic_string< char >& sid,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::ireon::client::config (wrap, h, f, p);
    }

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (::std::istream& is,
            const ::std::basic_string< char >& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::ireon::client::config (wrap, h, f, p);
    }

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::ireon::client::config (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (const ::xercesc::DOMInputSource& i,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< char > ();
      }

      return ::ireon::client::config (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< char > ();
      }

      return ::ireon::client::config (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< char > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      if (e.name () == "config" &&
          e.namespace_ () == "http://www.ireon.org/ireon/client/")
      {
        ::std::auto_ptr< ::ireon::client::CPCConfig > r (
          ::xsd::cxx::tree::traits< ::ireon::client::CPCConfig, char >::create (
            e.dom_element (), f, 0));
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        e.name (),
        e.namespace_ (),
        "config",
        "http://www.ireon.org/ireon/client/");
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/serialization.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace ireon
{
  namespace client
  {
    void
    config (::xercesc::DOMDocument& d,
            const ::ireon::client::CPCConfig& s,
            ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< char > e (*d.getDocumentElement ());

      if (e.name () == "config" &&
          e.namespace_ () == "http://www.ireon.org/ireon/client/")
      {
        e.dom_element () << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          e.name (),
          e.namespace_ (),
          "config",
          "http://www.ireon.org/ireon/client/");
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    config (const ::ireon::client::CPCConfig& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "config",
            "http://www.ireon.org/ireon/client/",
            m,
            f));
        ::ireon::client::config (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
      }
    }

    void
    config (::xercesc::XMLFormatTarget& t,
            const ::ireon::client::CPCConfig& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::ireon::client::config (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    config (::xercesc::XMLFormatTarget& t,
            const ::ireon::client::CPCConfig& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xsd::cxx::xml::error_handler< char >& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::ireon::client::config (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    config (::xercesc::XMLFormatTarget& t,
            const ::ireon::client::CPCConfig& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::ireon::client::config (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    config (::std::ostream& o,
            const ::ireon::client::CPCConfig& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::ireon::client::config (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    config (::std::ostream& o,
            const ::ireon::client::CPCConfig& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xsd::cxx::xml::error_handler< char >& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::ireon::client::config (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    config (::std::ostream& o,
            const ::ireon::client::CPCConfig& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::ireon::client::config (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CPCConfig& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        if (i.net ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "net",
            e);
          s.dom_element () << *i.net ();
        }
      }

      {
        if (i.resources ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "resources",
            e);
          s.dom_element () << *i.resources ();
        }
      }

      {
        if (i.world ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "world",
            e);
          s.dom_element () << *i.world ();
        }
      }

      {
        if (i.profile ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "profile",
            e);
          s.dom_element () << *i.profile ();
        }
      }

      {
        if (i._interface ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "_interface",
            e);
          s.dom_element () << *i._interface ();
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CNet& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        if (i.rootServer ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "rootServer",
            e);
          s.dom_element () << *i.rootServer ();
        }
      }

      {
        if (i.worldServer ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "worldServer",
            e);
          s.dom_element () << *i.worldServer ();
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CRootServer& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        if (i.ip ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "ip",
            e);
          s.dom_element () << *i.ip ();
        }
      }

      {
        if (i.port ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "port",
            e);
          s.dom_element () << *i.port ();
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CWorldServer& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        if (i.port ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "port",
            e);
          s.dom_element () << *i.port ();
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CIPv4Address& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                const CIPv4Address& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< char >& l,
                const CIPv4Address& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CPort& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                const CPort& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< char >& l,
                const CPort& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CWorldSettings& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        if (i.light ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "light",
            e);
          s.dom_element () << *i.light ();
        }
      }

      {
        if (i.worldPath ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "worldPath",
            e);
          s.dom_element () << *i.worldPath ();
        }
      }

      {
        if (i.proto ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "proto",
            e);
          s.dom_element () << *i.proto ();
        }
      }

      {
        if (i.dataPath ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "dataPath",
            e);
          s.dom_element () << *i.dataPath ();
        }
      }

      {
        if (i.player ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "player",
            e);
          s.dom_element () << *i.player ();
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CProtoSettings& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        if (i.directory ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "directory",
            e);
          s.dom_element () << *i.directory ();
        }
      }

      {
        if (i.loadAll ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "loadAll",
            e);
          s.dom_element () << *i.loadAll ();
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CPlayerSettings& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        if (i.mesh ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "mesh",
            e);
          s.dom_element () << *i.mesh ();
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CLightSettings& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "main",
          e);
        s.dom_element () << i.main ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "ambient",
          e);
        s.dom_element () << i.ambient ();
      }

      {
        if (i.shadows ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "shadows",
            e);
          s.dom_element () << *i.shadows ();
        }
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "enabled",
          e);

        a.dom_attribute () << i.enabled ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CShadowSettings& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "colour",
          e);
        s.dom_element () << i.colour ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "enabled",
          e);

        a.dom_attribute () << i.enabled ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CProfile& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "login",
          e);
        s.dom_element () << i.login ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "password",
          e);
        s.dom_element () << i.password ();
      }

      {
        if (i.registration ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "registration",
            e);
          s.dom_element () << *i.registration ();
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CInterfaceSettings& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        if (i.dir ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "dir",
            e);
          s.dom_element () << *i.dir ();
        }
      }

      {
        if (i.symbols ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "symbols",
            e);
          s.dom_element () << *i.symbols ();
        }
      }

      {
        for (CInterfaceSettings::script::const_iterator
             b (i.script ().begin ()), n (i.script ().end ());
             b != n; ++b)
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "script",
            e);
          s.dom_element () << *b;
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CResources& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        for (CResources::resource::const_iterator
             b (i.resource ().begin ()), n (i.resource ().end ());
             b != n; ++b)
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "resource",
            e);
          s.dom_element () << *b;
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CResourceItem& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "category",
          e);

        a.dom_attribute () << i.category ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "type",
          e);

        a.dom_attribute () << i.type ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

