// Copyright (C) 2005-2006 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// In addition, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "config_xsd.h"

namespace ireon
{
  namespace rs
  {
    // CRSConfig
    // 

    const CRSConfig::requiredClientVersion::container& CRSConfig::
    requiredClientVersion () const
    {
      return this->_xsd_requiredClientVersion_;
    }

    CRSConfig::requiredClientVersion::container& CRSConfig::
    requiredClientVersion ()
    {
      return this->_xsd_requiredClientVersion_;
    }

    void CRSConfig::
    requiredClientVersion (const requiredClientVersion::type& requiredClientVersion)
    {
      this->_xsd_requiredClientVersion_.set (requiredClientVersion);
    }

    void CRSConfig::
    requiredClientVersion (const requiredClientVersion::container& requiredClientVersion)
    {
      this->_xsd_requiredClientVersion_ = requiredClientVersion;
    }

    void CRSConfig::
    requiredClientVersion (::std::auto_ptr< requiredClientVersion::type > requiredClientVersion)
    {
      this->_xsd_requiredClientVersion_.set (requiredClientVersion);
    }

    const CRSConfig::playerConnectionsListener::container& CRSConfig::
    playerConnectionsListener () const
    {
      return this->_xsd_playerConnectionsListener_;
    }

    CRSConfig::playerConnectionsListener::container& CRSConfig::
    playerConnectionsListener ()
    {
      return this->_xsd_playerConnectionsListener_;
    }

    void CRSConfig::
    playerConnectionsListener (const playerConnectionsListener::type& playerConnectionsListener)
    {
      this->_xsd_playerConnectionsListener_.set (playerConnectionsListener);
    }

    void CRSConfig::
    playerConnectionsListener (const playerConnectionsListener::container& playerConnectionsListener)
    {
      this->_xsd_playerConnectionsListener_ = playerConnectionsListener;
    }

    void CRSConfig::
    playerConnectionsListener (::std::auto_ptr< playerConnectionsListener::type > playerConnectionsListener)
    {
      this->_xsd_playerConnectionsListener_.set (playerConnectionsListener);
    }

    const CRSConfig::wsConnectionsListener::container& CRSConfig::
    wsConnectionsListener () const
    {
      return this->_xsd_wsConnectionsListener_;
    }

    CRSConfig::wsConnectionsListener::container& CRSConfig::
    wsConnectionsListener ()
    {
      return this->_xsd_wsConnectionsListener_;
    }

    void CRSConfig::
    wsConnectionsListener (const wsConnectionsListener::type& wsConnectionsListener)
    {
      this->_xsd_wsConnectionsListener_.set (wsConnectionsListener);
    }

    void CRSConfig::
    wsConnectionsListener (const wsConnectionsListener::container& wsConnectionsListener)
    {
      this->_xsd_wsConnectionsListener_ = wsConnectionsListener;
    }

    void CRSConfig::
    wsConnectionsListener (::std::auto_ptr< wsConnectionsListener::type > wsConnectionsListener)
    {
      this->_xsd_wsConnectionsListener_.set (wsConnectionsListener);
    }

    const CRSConfig::db::type& CRSConfig::
    db () const
    {
      return this->_xsd_db_.get ();
    }

    CRSConfig::db::type& CRSConfig::
    db ()
    {
      return this->_xsd_db_.get ();
    }

    void CRSConfig::
    db (const db::type& db)
    {
      this->_xsd_db_.set (db);
    }

    void CRSConfig::
    db (::std::auto_ptr< db::type > db)
    {
      this->_xsd_db_.set (db);
    }


    // CPlayerListener
    // 

    const CPlayerListener::port::type& CPlayerListener::port::
    default_value ()
    {
      return default_value_;
    }

    const CPlayerListener::port::container& CPlayerListener::
    port () const
    {
      return this->_xsd_port_;
    }

    CPlayerListener::port::container& CPlayerListener::
    port ()
    {
      return this->_xsd_port_;
    }

    void CPlayerListener::
    port (const port::type& port)
    {
      this->_xsd_port_.set (port);
    }

    void CPlayerListener::
    port (const port::container& port)
    {
      this->_xsd_port_ = port;
    }

    void CPlayerListener::
    port (::std::auto_ptr< port::type > port)
    {
      this->_xsd_port_.set (port);
    }

    const CPlayerListener::maxConnections::type& CPlayerListener::maxConnections::
    default_value ()
    {
      return default_value_;
    }

    const CPlayerListener::maxConnections::container& CPlayerListener::
    maxConnections () const
    {
      return this->_xsd_maxConnections_;
    }

    CPlayerListener::maxConnections::container& CPlayerListener::
    maxConnections ()
    {
      return this->_xsd_maxConnections_;
    }

    void CPlayerListener::
    maxConnections (const maxConnections::type& maxConnections)
    {
      this->_xsd_maxConnections_.set (maxConnections);
    }

    void CPlayerListener::
    maxConnections (const maxConnections::container& maxConnections)
    {
      this->_xsd_maxConnections_ = maxConnections;
    }

    void CPlayerListener::
    maxConnections (::std::auto_ptr< maxConnections::type > maxConnections)
    {
      this->_xsd_maxConnections_.set (maxConnections);
    }


    // CWSListener
    // 

    const CWSListener::port::type& CWSListener::port::
    default_value ()
    {
      return default_value_;
    }

    const CWSListener::port::container& CWSListener::
    port () const
    {
      return this->_xsd_port_;
    }

    CWSListener::port::container& CWSListener::
    port ()
    {
      return this->_xsd_port_;
    }

    void CWSListener::
    port (const port::type& port)
    {
      this->_xsd_port_.set (port);
    }

    void CWSListener::
    port (const port::container& port)
    {
      this->_xsd_port_ = port;
    }

    void CWSListener::
    port (::std::auto_ptr< port::type > port)
    {
      this->_xsd_port_.set (port);
    }

    const CWSListener::maxConnections::type& CWSListener::maxConnections::
    default_value ()
    {
      return default_value_;
    }

    const CWSListener::maxConnections::container& CWSListener::
    maxConnections () const
    {
      return this->_xsd_maxConnections_;
    }

    CWSListener::maxConnections::container& CWSListener::
    maxConnections ()
    {
      return this->_xsd_maxConnections_;
    }

    void CWSListener::
    maxConnections (const maxConnections::type& maxConnections)
    {
      this->_xsd_maxConnections_.set (maxConnections);
    }

    void CWSListener::
    maxConnections (const maxConnections::container& maxConnections)
    {
      this->_xsd_maxConnections_ = maxConnections;
    }

    void CWSListener::
    maxConnections (::std::auto_ptr< maxConnections::type > maxConnections)
    {
      this->_xsd_maxConnections_.set (maxConnections);
    }


    // CClientVersion
    // 

    const CClientVersion::major::type& CClientVersion::major::
    default_value ()
    {
      return default_value_;
    }

    const CClientVersion::major::type& CClientVersion::
    major () const
    {
      return this->_xsd_major_.get ();
    }

    CClientVersion::major::type& CClientVersion::
    major ()
    {
      return this->_xsd_major_.get ();
    }

    void CClientVersion::
    major (const major::type& major)
    {
      this->_xsd_major_.set (major);
    }

    const CClientVersion::minor::type& CClientVersion::minor::
    default_value ()
    {
      return default_value_;
    }

    const CClientVersion::minor::type& CClientVersion::
    minor () const
    {
      return this->_xsd_minor_.get ();
    }

    CClientVersion::minor::type& CClientVersion::
    minor ()
    {
      return this->_xsd_minor_.get ();
    }

    void CClientVersion::
    minor (const minor::type& minor)
    {
      this->_xsd_minor_.set (minor);
    }

    const CClientVersion::release::type& CClientVersion::release::
    default_value ()
    {
      return default_value_;
    }

    const CClientVersion::release::type& CClientVersion::
    release () const
    {
      return this->_xsd_release_.get ();
    }

    CClientVersion::release::type& CClientVersion::
    release ()
    {
      return this->_xsd_release_.get ();
    }

    void CClientVersion::
    release (const release::type& release)
    {
      this->_xsd_release_.set (release);
    }

    const CClientVersion::build::type& CClientVersion::build::
    default_value ()
    {
      return default_value_;
    }

    const CClientVersion::build::type& CClientVersion::
    build () const
    {
      return this->_xsd_build_.get ();
    }

    CClientVersion::build::type& CClientVersion::
    build ()
    {
      return this->_xsd_build_.get ();
    }

    void CClientVersion::
    build (const build::type& build)
    {
      this->_xsd_build_.set (build);
    }


    // CDBconnection
    // 

    const CDBconnection::ip::type& CDBconnection::ip::
    default_value ()
    {
      return default_value_;
    }

    const CDBconnection::ip::container& CDBconnection::
    ip () const
    {
      return this->_xsd_ip_;
    }

    CDBconnection::ip::container& CDBconnection::
    ip ()
    {
      return this->_xsd_ip_;
    }

    void CDBconnection::
    ip (const ip::type& ip)
    {
      this->_xsd_ip_.set (ip);
    }

    void CDBconnection::
    ip (const ip::container& ip)
    {
      this->_xsd_ip_ = ip;
    }

    void CDBconnection::
    ip (::std::auto_ptr< ip::type > ip)
    {
      this->_xsd_ip_.set (ip);
    }

    const CDBconnection::port::type& CDBconnection::port::
    default_value ()
    {
      return default_value_;
    }

    const CDBconnection::port::container& CDBconnection::
    port () const
    {
      return this->_xsd_port_;
    }

    CDBconnection::port::container& CDBconnection::
    port ()
    {
      return this->_xsd_port_;
    }

    void CDBconnection::
    port (const port::type& port)
    {
      this->_xsd_port_.set (port);
    }

    void CDBconnection::
    port (const port::container& port)
    {
      this->_xsd_port_ = port;
    }

    void CDBconnection::
    port (::std::auto_ptr< port::type > port)
    {
      this->_xsd_port_.set (port);
    }

    const CDBconnection::login::type& CDBconnection::
    login () const
    {
      return this->_xsd_login_.get ();
    }

    CDBconnection::login::type& CDBconnection::
    login ()
    {
      return this->_xsd_login_.get ();
    }

    void CDBconnection::
    login (const login::type& login)
    {
      this->_xsd_login_.set (login);
    }

    void CDBconnection::
    login (::std::auto_ptr< login::type > login)
    {
      this->_xsd_login_.set (login);
    }

    const CDBconnection::password::type& CDBconnection::
    password () const
    {
      return this->_xsd_password_.get ();
    }

    CDBconnection::password::type& CDBconnection::
    password ()
    {
      return this->_xsd_password_.get ();
    }

    void CDBconnection::
    password (const password::type& password)
    {
      this->_xsd_password_.set (password);
    }

    void CDBconnection::
    password (::std::auto_ptr< password::type > password)
    {
      this->_xsd_password_.set (password);
    }

    const CDBconnection::schema::type& CDBconnection::schema::
    default_value ()
    {
      return default_value_;
    }

    const CDBconnection::schema::container& CDBconnection::
    schema () const
    {
      return this->_xsd_schema_;
    }

    CDBconnection::schema::container& CDBconnection::
    schema ()
    {
      return this->_xsd_schema_;
    }

    void CDBconnection::
    schema (const schema::type& schema)
    {
      this->_xsd_schema_.set (schema);
    }

    void CDBconnection::
    schema (const schema::container& schema)
    {
      this->_xsd_schema_ = schema;
    }

    void CDBconnection::
    schema (::std::auto_ptr< schema::type > schema)
    {
      this->_xsd_schema_.set (schema);
    }


    // CIPv4Address
    // 


    // CPort
    // 


    // CConnectionsNumber
    // 
  }
}

#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/parser.hxx>

namespace ireon
{
  namespace rs
  {
    // CRSConfig
    //

    CRSConfig::
    CRSConfig (const db::type& _xsd_db)
    : ::xml_schema::type (),
    _xsd_requiredClientVersion_ (::xml_schema::flags (), this),
    _xsd_playerConnectionsListener_ (::xml_schema::flags (), this),
    _xsd_wsConnectionsListener_ (::xml_schema::flags (), this),
    _xsd_db_ (_xsd_db,
              ::xml_schema::flags (),
              this)
    {
    }

    CRSConfig::
    CRSConfig (const CRSConfig& _xsd_CRSConfig,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CRSConfig, f, c),
    _xsd_requiredClientVersion_ (_xsd_CRSConfig._xsd_requiredClientVersion_,
                                 f | ::xml_schema::flags::not_root,
                                 this),
    _xsd_playerConnectionsListener_ (_xsd_CRSConfig._xsd_playerConnectionsListener_,
                                     f | ::xml_schema::flags::not_root,
                                     this),
    _xsd_wsConnectionsListener_ (_xsd_CRSConfig._xsd_wsConnectionsListener_,
                                 f | ::xml_schema::flags::not_root,
                                 this),
    _xsd_db_ (_xsd_CRSConfig._xsd_db_,
              f | ::xml_schema::flags::not_root,
              this)
    {
    }

    CRSConfig::
    CRSConfig (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_requiredClientVersion_ (f | ::xml_schema::flags::not_root, this),
    _xsd_playerConnectionsListener_ (f | ::xml_schema::flags::not_root, this),
    _xsd_wsConnectionsListener_ (f | ::xml_schema::flags::not_root, this),
    _xsd_db_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CRSConfig::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // requiredClientVersion
        //
        {
          if (e.name () == "requiredClientVersion" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< requiredClientVersion::type > r (
              requiredClientVersion::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->requiredClientVersion ())
              continue;
            this->requiredClientVersion (r);
            continue;
          }
        }

        // playerConnectionsListener
        //
        {
          if (e.name () == "playerConnectionsListener" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< playerConnectionsListener::type > r (
              playerConnectionsListener::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->playerConnectionsListener ())
              continue;
            this->playerConnectionsListener (r);
            continue;
          }
        }

        // wsConnectionsListener
        //
        {
          if (e.name () == "wsConnectionsListener" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< wsConnectionsListener::type > r (
              wsConnectionsListener::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->wsConnectionsListener ())
              continue;
            this->wsConnectionsListener (r);
            continue;
          }
        }

        // db
        //
        {
          if (e.name () == "db" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< db::type > r (
              db::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_db_.present ())
              continue;
            this->db (r);
            continue;
          }
        }
      }

      if (!_xsd_db_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "db",
          "");
      }
    }

    CRSConfig* CRSConfig::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CRSConfig (*this, f, c);
    }

    // CPlayerListener
    //

    // CPlayerListener::port
    // 

    const CPlayerListener::port::type CPlayerListener::port::default_value_ (
      ::std::basic_string< char > ("29100"), 0, 0, 0);

    // CPlayerListener::maxConnections
    // 

    const CPlayerListener::maxConnections::type CPlayerListener::maxConnections::default_value_ (
      ::std::basic_string< char > ("10"), 0, 0, 0);

    CPlayerListener::
    CPlayerListener ()
    : ::xml_schema::type (),
    _xsd_port_ (::xml_schema::flags (), this),
    _xsd_maxConnections_ (::xml_schema::flags (), this)
    {
    }

    CPlayerListener::
    CPlayerListener (const CPlayerListener& _xsd_CPlayerListener,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CPlayerListener, f, c),
    _xsd_port_ (_xsd_CPlayerListener._xsd_port_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_maxConnections_ (_xsd_CPlayerListener._xsd_maxConnections_,
                          f | ::xml_schema::flags::not_root,
                          this)
    {
    }

    CPlayerListener::
    CPlayerListener (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_port_ (f | ::xml_schema::flags::not_root, this),
    _xsd_maxConnections_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CPlayerListener::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // port
        //
        {
          if (e.name () == "port" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< port::type > r (
              port::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->port ())
              continue;
            this->port (r);
            continue;
          }
        }

        // maxConnections
        //
        {
          if (e.name () == "maxConnections" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< maxConnections::type > r (
              maxConnections::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->maxConnections ())
              continue;
            this->maxConnections (r);
            continue;
          }
        }
      }
    }

    CPlayerListener* CPlayerListener::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CPlayerListener (*this, f, c);
    }

    // CWSListener
    //

    // CWSListener::port
    // 

    const CWSListener::port::type CWSListener::port::default_value_ (
      ::std::basic_string< char > ("29105"), 0, 0, 0);

    // CWSListener::maxConnections
    // 

    const CWSListener::maxConnections::type CWSListener::maxConnections::default_value_ (
      ::std::basic_string< char > ("2"), 0, 0, 0);

    CWSListener::
    CWSListener ()
    : ::xml_schema::type (),
    _xsd_port_ (::xml_schema::flags (), this),
    _xsd_maxConnections_ (::xml_schema::flags (), this)
    {
    }

    CWSListener::
    CWSListener (const CWSListener& _xsd_CWSListener,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CWSListener, f, c),
    _xsd_port_ (_xsd_CWSListener._xsd_port_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_maxConnections_ (_xsd_CWSListener._xsd_maxConnections_,
                          f | ::xml_schema::flags::not_root,
                          this)
    {
    }

    CWSListener::
    CWSListener (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_port_ (f | ::xml_schema::flags::not_root, this),
    _xsd_maxConnections_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CWSListener::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // port
        //
        {
          if (e.name () == "port" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< port::type > r (
              port::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->port ())
              continue;
            this->port (r);
            continue;
          }
        }

        // maxConnections
        //
        {
          if (e.name () == "maxConnections" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< maxConnections::type > r (
              maxConnections::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->maxConnections ())
              continue;
            this->maxConnections (r);
            continue;
          }
        }
      }
    }

    CWSListener* CWSListener::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CWSListener (*this, f, c);
    }

    // CClientVersion
    //

    // CClientVersion::major
    // 

    const CClientVersion::major::type CClientVersion::major::default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::unsigned_byte, char >::create (
        ::std::basic_string< char > ("0"), 0, 0, 0));

    // CClientVersion::minor
    // 

    const CClientVersion::minor::type CClientVersion::minor::default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::unsigned_byte, char >::create (
        ::std::basic_string< char > ("1"), 0, 0, 0));

    // CClientVersion::release
    // 

    const CClientVersion::release::type CClientVersion::release::default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::unsigned_short, char >::create (
        ::std::basic_string< char > ("4"), 0, 0, 0));

    // CClientVersion::build
    // 

    const CClientVersion::build::type CClientVersion::build::default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::unsigned_short, char >::create (
        ::std::basic_string< char > ("50"), 0, 0, 0));

    CClientVersion::
    CClientVersion (const major::type& _xsd_major,
                    const minor::type& _xsd_minor,
                    const release::type& _xsd_release,
                    const build::type& _xsd_build)
    : ::xml_schema::type (),
    _xsd_major_ (_xsd_major,
                 ::xml_schema::flags (),
                 this),
    _xsd_minor_ (_xsd_minor,
                 ::xml_schema::flags (),
                 this),
    _xsd_release_ (_xsd_release,
                   ::xml_schema::flags (),
                   this),
    _xsd_build_ (_xsd_build,
                 ::xml_schema::flags (),
                 this)
    {
    }

    CClientVersion::
    CClientVersion (const CClientVersion& _xsd_CClientVersion,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CClientVersion, f, c),
    _xsd_major_ (_xsd_CClientVersion._xsd_major_,
                 f | ::xml_schema::flags::not_root,
                 this),
    _xsd_minor_ (_xsd_CClientVersion._xsd_minor_,
                 f | ::xml_schema::flags::not_root,
                 this),
    _xsd_release_ (_xsd_CClientVersion._xsd_release_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd_build_ (_xsd_CClientVersion._xsd_build_,
                 f | ::xml_schema::flags::not_root,
                 this)
    {
    }

    CClientVersion::
    CClientVersion (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_major_ (f | ::xml_schema::flags::not_root, this),
    _xsd_minor_ (f | ::xml_schema::flags::not_root, this),
    _xsd_release_ (f | ::xml_schema::flags::not_root, this),
    _xsd_build_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CClientVersion::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // major
        //
        {
          if (e.name () == "major" && e.namespace_ ().empty ())
          {
            if (_xsd_major_.present ())
              continue;
            this->major (
              major::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }
        }

        // minor
        //
        {
          if (e.name () == "minor" && e.namespace_ ().empty ())
          {
            if (_xsd_minor_.present ())
              continue;
            this->minor (
              minor::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }
        }

        // release
        //
        {
          if (e.name () == "release" && e.namespace_ ().empty ())
          {
            if (_xsd_release_.present ())
              continue;
            this->release (
              release::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }
        }

        // build
        //
        {
          if (e.name () == "build" && e.namespace_ ().empty ())
          {
            if (_xsd_build_.present ())
              continue;
            this->build (
              build::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }
        }
      }

      if (!_xsd_major_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "major",
          "");
      }

      if (!_xsd_minor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "minor",
          "");
      }

      if (!_xsd_release_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "release",
          "");
      }

      if (!_xsd_build_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "build",
          "");
      }
    }

    CClientVersion* CClientVersion::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CClientVersion (*this, f, c);
    }

    // CDBconnection
    //

    // CDBconnection::ip
    // 

    const CDBconnection::ip::type CDBconnection::ip::default_value_ (
      ::std::basic_string< char > ("127.0.0.1"), 0, 0, 0);

    // CDBconnection::port
    // 

    const CDBconnection::port::type CDBconnection::port::default_value_ (
      ::std::basic_string< char > ("3306"), 0, 0, 0);

    // CDBconnection::schema
    // 

    const CDBconnection::schema::type CDBconnection::schema::default_value_ (
      ::std::basic_string< char > ("rs"), 0, 0, 0);

    CDBconnection::
    CDBconnection (const login::type& _xsd_login,
                   const password::type& _xsd_password)
    : ::xml_schema::type (),
    _xsd_ip_ (::xml_schema::flags (), this),
    _xsd_port_ (::xml_schema::flags (), this),
    _xsd_login_ (_xsd_login,
                 ::xml_schema::flags (),
                 this),
    _xsd_password_ (_xsd_password,
                    ::xml_schema::flags (),
                    this),
    _xsd_schema_ (::xml_schema::flags (), this)
    {
    }

    CDBconnection::
    CDBconnection (const CDBconnection& _xsd_CDBconnection,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_CDBconnection, f, c),
    _xsd_ip_ (_xsd_CDBconnection._xsd_ip_,
              f | ::xml_schema::flags::not_root,
              this),
    _xsd_port_ (_xsd_CDBconnection._xsd_port_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_login_ (_xsd_CDBconnection._xsd_login_,
                 f | ::xml_schema::flags::not_root,
                 this),
    _xsd_password_ (_xsd_CDBconnection._xsd_password_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_schema_ (_xsd_CDBconnection._xsd_schema_,
                  f | ::xml_schema::flags::not_root,
                  this)
    {
    }

    CDBconnection::
    CDBconnection (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_ip_ (f | ::xml_schema::flags::not_root, this),
    _xsd_port_ (f | ::xml_schema::flags::not_root, this),
    _xsd_login_ (f | ::xml_schema::flags::not_root, this),
    _xsd_password_ (f | ::xml_schema::flags::not_root, this),
    _xsd_schema_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void CDBconnection::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // ip
        //
        {
          if (e.name () == "ip" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< ip::type > r (
              ip::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->ip ())
              continue;
            this->ip (r);
            continue;
          }
        }

        // port
        //
        {
          if (e.name () == "port" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< port::type > r (
              port::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->port ())
              continue;
            this->port (r);
            continue;
          }
        }

        // login
        //
        {
          if (e.name () == "login" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< login::type > r (
              login::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_login_.present ())
              continue;
            this->login (r);
            continue;
          }
        }

        // password
        //
        {
          if (e.name () == "password" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< password::type > r (
              password::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_password_.present ())
              continue;
            this->password (r);
            continue;
          }
        }

        // schema
        //
        {
          if (e.name () == "schema" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< schema::type > r (
              schema::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->schema ())
              continue;
            this->schema (r);
            continue;
          }
        }
      }

      if (!_xsd_login_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "login",
          "");
      }

      if (!_xsd_password_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "password",
          "");
      }
    }

    CDBconnection* CDBconnection::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CDBconnection (*this, f, c);
    }

    // CIPv4Address
    //

    CIPv4Address::
    CIPv4Address (const _xsd_CIPv4Address::base_& _xsd_CIPv4Address)
    : ::xml_schema::string (_xsd_CIPv4Address)
    {
    }

    CIPv4Address::
    CIPv4Address (const CIPv4Address& _xsd_CIPv4Address,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (_xsd_CIPv4Address, f, c)
    {
    }

    CIPv4Address::
    CIPv4Address (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    CIPv4Address::
    CIPv4Address (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    CIPv4Address::
    CIPv4Address (const ::std::basic_string< char >& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    CIPv4Address* CIPv4Address::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CIPv4Address (*this, f, c);
    }

    // CPort
    //

    CPort::
    CPort (const _xsd_CPort::base_& _xsd_CPort)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (_xsd_CPort)
    {
    }

    CPort::
    CPort (const CPort& _xsd_CPort,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (_xsd_CPort, f, c)
    {
    }

    CPort::
    CPort (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    CPort::
    CPort (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    CPort::
    CPort (const ::std::basic_string< char >& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    CPort* CPort::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CPort (*this, f, c);
    }

    // CConnectionsNumber
    //

    CConnectionsNumber::
    CConnectionsNumber (const _xsd_CConnectionsNumber::base_& _xsd_CConnectionsNumber)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (_xsd_CConnectionsNumber)
    {
    }

    CConnectionsNumber::
    CConnectionsNumber (const CConnectionsNumber& _xsd_CConnectionsNumber,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (_xsd_CConnectionsNumber, f, c)
    {
    }

    CConnectionsNumber::
    CConnectionsNumber (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    CConnectionsNumber::
    CConnectionsNumber (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    CConnectionsNumber::
    CConnectionsNumber (const ::std::basic_string< char >& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    CConnectionsNumber* CConnectionsNumber::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new CConnectionsNumber (*this, f, c);
    }
  }
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace ireon
{
  namespace rs
  {
    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (const ::std::basic_string< char >& u,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::ireon::rs::config (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (const ::std::basic_string< char >& u,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< char > ();
      }

      return ::ireon::rs::config (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (const ::std::basic_string< char >& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< char > ();
      }

      return ::ireon::rs::config (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (::std::istream& is,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::ireon::rs::config (wrap, f, p);
    }

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (::std::istream& is,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::ireon::rs::config (wrap, h, f, p);
    }

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::ireon::rs::config (wrap, h, f, p);
    }

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (::std::istream& is,
            const ::std::basic_string< char >& sid,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::ireon::rs::config (wrap, f, p);
    }

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (::std::istream& is,
            const ::std::basic_string< char >& sid,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::ireon::rs::config (wrap, h, f, p);
    }

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (::std::istream& is,
            const ::std::basic_string< char >& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::ireon::rs::config (wrap, h, f, p);
    }

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::ireon::rs::config (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (const ::xercesc::DOMInputSource& i,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< char > ();
      }

      return ::ireon::rs::config (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< char > ();
      }

      return ::ireon::rs::config (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< char > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      if (e.name () == "config" &&
          e.namespace_ () == "http://www.ireon.org/ireon/rs/")
      {
        ::std::auto_ptr< ::ireon::rs::CRSConfig > r (
          ::xsd::cxx::tree::traits< ::ireon::rs::CRSConfig, char >::create (
            e.dom_element (), f, 0));
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        e.name (),
        e.namespace_ (),
        "config",
        "http://www.ireon.org/ireon/rs/");
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/serialization.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace ireon
{
  namespace rs
  {
    void
    config (::xercesc::DOMDocument& d,
            const ::ireon::rs::CRSConfig& s,
            ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< char > e (*d.getDocumentElement ());

      if (e.name () == "config" &&
          e.namespace_ () == "http://www.ireon.org/ireon/rs/")
      {
        e.dom_element () << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          e.name (),
          e.namespace_ (),
          "config",
          "http://www.ireon.org/ireon/rs/");
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    config (const ::ireon::rs::CRSConfig& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "config",
            "http://www.ireon.org/ireon/rs/",
            m,
            f));
        ::ireon::rs::config (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
      }
    }

    void
    config (::xercesc::XMLFormatTarget& t,
            const ::ireon::rs::CRSConfig& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::ireon::rs::config (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    config (::xercesc::XMLFormatTarget& t,
            const ::ireon::rs::CRSConfig& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xsd::cxx::xml::error_handler< char >& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::ireon::rs::config (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    config (::xercesc::XMLFormatTarget& t,
            const ::ireon::rs::CRSConfig& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::ireon::rs::config (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    config (::std::ostream& o,
            const ::ireon::rs::CRSConfig& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::ireon::rs::config (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    config (::std::ostream& o,
            const ::ireon::rs::CRSConfig& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xsd::cxx::xml::error_handler< char >& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::ireon::rs::config (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    config (::std::ostream& o,
            const ::ireon::rs::CRSConfig& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::ireon::rs::config (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CRSConfig& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        if (i.requiredClientVersion ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "requiredClientVersion",
            e);
          s.dom_element () << *i.requiredClientVersion ();
        }
      }

      {
        if (i.playerConnectionsListener ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "playerConnectionsListener",
            e);
          s.dom_element () << *i.playerConnectionsListener ();
        }
      }

      {
        if (i.wsConnectionsListener ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "wsConnectionsListener",
            e);
          s.dom_element () << *i.wsConnectionsListener ();
        }
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "db",
          e);
        s.dom_element () << i.db ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CPlayerListener& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        if (i.port ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "port",
            e);
          s.dom_element () << *i.port ();
        }
      }

      {
        if (i.maxConnections ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "maxConnections",
            e);
          s.dom_element () << *i.maxConnections ();
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CWSListener& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        if (i.port ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "port",
            e);
          s.dom_element () << *i.port ();
        }
      }

      {
        if (i.maxConnections ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "maxConnections",
            e);
          s.dom_element () << *i.maxConnections ();
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CClientVersion& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "major",
          e);
        s.dom_element () << i.major ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "minor",
          e);
        s.dom_element () << i.minor ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "release",
          e);
        s.dom_element () << i.release ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "build",
          e);
        s.dom_element () << i.build ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CDBconnection& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        if (i.ip ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "ip",
            e);
          s.dom_element () << *i.ip ();
        }
      }

      {
        if (i.port ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "port",
            e);
          s.dom_element () << *i.port ();
        }
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "login",
          e);
        s.dom_element () << i.login ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "password",
          e);
        s.dom_element () << i.password ();
      }

      {
        if (i.schema ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "schema",
            e);
          s.dom_element () << *i.schema ();
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CIPv4Address& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                const CIPv4Address& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< char >& l,
                const CIPv4Address& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CPort& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                const CPort& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< char >& l,
                const CPort& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const CConnectionsNumber& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                const CConnectionsNumber& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< char >& l,
                const CConnectionsNumber& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type >& > (i);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

