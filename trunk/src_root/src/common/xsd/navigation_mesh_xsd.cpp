// Copyright (C) 2005-2006 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// In addition, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "navigation_mesh_xsd.h"

namespace ireon
{
  namespace ws
  {
    namespace navmesh_cfg
    {
      // Mesh
      // 

      const Mesh::submeshes::type& Mesh::
      submeshes () const
      {
        return this->_xsd_submeshes_.get ();
      }

      Mesh::submeshes::type& Mesh::
      submeshes ()
      {
        return this->_xsd_submeshes_.get ();
      }

      void Mesh::
      submeshes (const submeshes::type& submeshes)
      {
        this->_xsd_submeshes_.set (submeshes);
      }

      void Mesh::
      submeshes (::std::auto_ptr< submeshes::type > submeshes)
      {
        this->_xsd_submeshes_.set (submeshes);
      }


      // Submeshes
      // 

      const Submeshes::submesh::container& Submeshes::
      submesh () const
      {
        return this->_xsd_submesh_;
      }

      Submeshes::submesh::container& Submeshes::
      submesh ()
      {
        return this->_xsd_submesh_;
      }

      void Submeshes::
      submesh (const submesh::container& submesh)
      {
        this->_xsd_submesh_ = submesh;
      }


      // Submesh
      // 

      const Submesh::faces::type& Submesh::
      faces () const
      {
        return this->_xsd_faces_.get ();
      }

      Submesh::faces::type& Submesh::
      faces ()
      {
        return this->_xsd_faces_.get ();
      }

      void Submesh::
      faces (const faces::type& faces)
      {
        this->_xsd_faces_.set (faces);
      }

      void Submesh::
      faces (::std::auto_ptr< faces::type > faces)
      {
        this->_xsd_faces_.set (faces);
      }

      const Submesh::geometry::type& Submesh::
      geometry () const
      {
        return this->_xsd_geometry_.get ();
      }

      Submesh::geometry::type& Submesh::
      geometry ()
      {
        return this->_xsd_geometry_.get ();
      }

      void Submesh::
      geometry (const geometry::type& geometry)
      {
        this->_xsd_geometry_.set (geometry);
      }

      void Submesh::
      geometry (::std::auto_ptr< geometry::type > geometry)
      {
        this->_xsd_geometry_.set (geometry);
      }

      const Submesh::material::container& Submesh::
      material () const
      {
        return this->_xsd_material_;
      }

      Submesh::material::container& Submesh::
      material ()
      {
        return this->_xsd_material_;
      }

      void Submesh::
      material (const material::type& material)
      {
        this->_xsd_material_.set (material);
      }

      void Submesh::
      material (const material::container& material)
      {
        this->_xsd_material_ = material;
      }

      void Submesh::
      material (::std::auto_ptr< material::type > material)
      {
        this->_xsd_material_.set (material);
      }

      const Submesh::usesharedvertices::container& Submesh::
      usesharedvertices () const
      {
        return this->_xsd_usesharedvertices_;
      }

      Submesh::usesharedvertices::container& Submesh::
      usesharedvertices ()
      {
        return this->_xsd_usesharedvertices_;
      }

      void Submesh::
      usesharedvertices (const usesharedvertices::type& usesharedvertices)
      {
        this->_xsd_usesharedvertices_.set (usesharedvertices);
      }

      void Submesh::
      usesharedvertices (const usesharedvertices::container& usesharedvertices)
      {
        this->_xsd_usesharedvertices_ = usesharedvertices;
      }

      const Submesh::use32bitindexes::container& Submesh::
      use32bitindexes () const
      {
        return this->_xsd_use32bitindexes_;
      }

      Submesh::use32bitindexes::container& Submesh::
      use32bitindexes ()
      {
        return this->_xsd_use32bitindexes_;
      }

      void Submesh::
      use32bitindexes (const use32bitindexes::type& use32bitindexes)
      {
        this->_xsd_use32bitindexes_.set (use32bitindexes);
      }

      void Submesh::
      use32bitindexes (const use32bitindexes::container& use32bitindexes)
      {
        this->_xsd_use32bitindexes_ = use32bitindexes;
      }


      // Faces
      // 

      const Faces::face::container& Faces::
      face () const
      {
        return this->_xsd_face_;
      }

      Faces::face::container& Faces::
      face ()
      {
        return this->_xsd_face_;
      }

      void Faces::
      face (const face::container& face)
      {
        this->_xsd_face_ = face;
      }

      const Faces::count::type& Faces::
      count () const
      {
        return this->_xsd_count_.get ();
      }

      Faces::count::type& Faces::
      count ()
      {
        return this->_xsd_count_.get ();
      }

      void Faces::
      count (const count::type& count)
      {
        this->_xsd_count_.set (count);
      }


      // Face
      // 

      const Face::v1::type& Face::
      v1 () const
      {
        return this->_xsd_v1_.get ();
      }

      Face::v1::type& Face::
      v1 ()
      {
        return this->_xsd_v1_.get ();
      }

      void Face::
      v1 (const v1::type& v1)
      {
        this->_xsd_v1_.set (v1);
      }

      const Face::v2::type& Face::
      v2 () const
      {
        return this->_xsd_v2_.get ();
      }

      Face::v2::type& Face::
      v2 ()
      {
        return this->_xsd_v2_.get ();
      }

      void Face::
      v2 (const v2::type& v2)
      {
        this->_xsd_v2_.set (v2);
      }

      const Face::v3::type& Face::
      v3 () const
      {
        return this->_xsd_v3_.get ();
      }

      Face::v3::type& Face::
      v3 ()
      {
        return this->_xsd_v3_.get ();
      }

      void Face::
      v3 (const v3::type& v3)
      {
        this->_xsd_v3_.set (v3);
      }


      // Geometry
      // 

      const Geometry::vertexbuffer::type& Geometry::
      vertexbuffer () const
      {
        return this->_xsd_vertexbuffer_.get ();
      }

      Geometry::vertexbuffer::type& Geometry::
      vertexbuffer ()
      {
        return this->_xsd_vertexbuffer_.get ();
      }

      void Geometry::
      vertexbuffer (const vertexbuffer::type& vertexbuffer)
      {
        this->_xsd_vertexbuffer_.set (vertexbuffer);
      }

      void Geometry::
      vertexbuffer (::std::auto_ptr< vertexbuffer::type > vertexbuffer)
      {
        this->_xsd_vertexbuffer_.set (vertexbuffer);
      }

      const Geometry::vertexcount::type& Geometry::
      vertexcount () const
      {
        return this->_xsd_vertexcount_.get ();
      }

      Geometry::vertexcount::type& Geometry::
      vertexcount ()
      {
        return this->_xsd_vertexcount_.get ();
      }

      void Geometry::
      vertexcount (const vertexcount::type& vertexcount)
      {
        this->_xsd_vertexcount_.set (vertexcount);
      }


      // VertexBuffer
      // 

      const VertexBuffer::vertex::container& VertexBuffer::
      vertex () const
      {
        return this->_xsd_vertex_;
      }

      VertexBuffer::vertex::container& VertexBuffer::
      vertex ()
      {
        return this->_xsd_vertex_;
      }

      void VertexBuffer::
      vertex (const vertex::container& vertex)
      {
        this->_xsd_vertex_ = vertex;
      }

      const VertexBuffer::positions::container& VertexBuffer::
      positions () const
      {
        return this->_xsd_positions_;
      }

      VertexBuffer::positions::container& VertexBuffer::
      positions ()
      {
        return this->_xsd_positions_;
      }

      void VertexBuffer::
      positions (const positions::type& positions)
      {
        this->_xsd_positions_.set (positions);
      }

      void VertexBuffer::
      positions (const positions::container& positions)
      {
        this->_xsd_positions_ = positions;
      }

      const VertexBuffer::normals::container& VertexBuffer::
      normals () const
      {
        return this->_xsd_normals_;
      }

      VertexBuffer::normals::container& VertexBuffer::
      normals ()
      {
        return this->_xsd_normals_;
      }

      void VertexBuffer::
      normals (const normals::type& normals)
      {
        this->_xsd_normals_.set (normals);
      }

      void VertexBuffer::
      normals (const normals::container& normals)
      {
        this->_xsd_normals_ = normals;
      }

      const VertexBuffer::colours_diffuse::container& VertexBuffer::
      colours_diffuse () const
      {
        return this->_xsd_colours_diffuse_;
      }

      VertexBuffer::colours_diffuse::container& VertexBuffer::
      colours_diffuse ()
      {
        return this->_xsd_colours_diffuse_;
      }

      void VertexBuffer::
      colours_diffuse (const colours_diffuse::type& colours_diffuse)
      {
        this->_xsd_colours_diffuse_.set (colours_diffuse);
      }

      void VertexBuffer::
      colours_diffuse (const colours_diffuse::container& colours_diffuse)
      {
        this->_xsd_colours_diffuse_ = colours_diffuse;
      }

      const VertexBuffer::texture_coords::container& VertexBuffer::
      texture_coords () const
      {
        return this->_xsd_texture_coords_;
      }

      VertexBuffer::texture_coords::container& VertexBuffer::
      texture_coords ()
      {
        return this->_xsd_texture_coords_;
      }

      void VertexBuffer::
      texture_coords (const texture_coords::type& texture_coords)
      {
        this->_xsd_texture_coords_.set (texture_coords);
      }

      void VertexBuffer::
      texture_coords (const texture_coords::container& texture_coords)
      {
        this->_xsd_texture_coords_ = texture_coords;
      }

      const VertexBuffer::texture_coords_dimensions_0::container& VertexBuffer::
      texture_coords_dimensions_0 () const
      {
        return this->_xsd_texture_coords_dimensions_0_;
      }

      VertexBuffer::texture_coords_dimensions_0::container& VertexBuffer::
      texture_coords_dimensions_0 ()
      {
        return this->_xsd_texture_coords_dimensions_0_;
      }

      void VertexBuffer::
      texture_coords_dimensions_0 (const texture_coords_dimensions_0::type& texture_coords_dimensions_0)
      {
        this->_xsd_texture_coords_dimensions_0_.set (texture_coords_dimensions_0);
      }

      void VertexBuffer::
      texture_coords_dimensions_0 (const texture_coords_dimensions_0::container& texture_coords_dimensions_0)
      {
        this->_xsd_texture_coords_dimensions_0_ = texture_coords_dimensions_0;
      }


      // Vertex
      // 

      const Vertex::position::type& Vertex::
      position () const
      {
        return this->_xsd_position_.get ();
      }

      Vertex::position::type& Vertex::
      position ()
      {
        return this->_xsd_position_.get ();
      }

      void Vertex::
      position (const position::type& position)
      {
        this->_xsd_position_.set (position);
      }

      void Vertex::
      position (::std::auto_ptr< position::type > position)
      {
        this->_xsd_position_.set (position);
      }

      const Vertex::normal::type& Vertex::
      normal () const
      {
        return this->_xsd_normal_.get ();
      }

      Vertex::normal::type& Vertex::
      normal ()
      {
        return this->_xsd_normal_.get ();
      }

      void Vertex::
      normal (const normal::type& normal)
      {
        this->_xsd_normal_.set (normal);
      }

      void Vertex::
      normal (::std::auto_ptr< normal::type > normal)
      {
        this->_xsd_normal_.set (normal);
      }

      const Vertex::texcoord::type& Vertex::
      texcoord () const
      {
        return this->_xsd_texcoord_.get ();
      }

      Vertex::texcoord::type& Vertex::
      texcoord ()
      {
        return this->_xsd_texcoord_.get ();
      }

      void Vertex::
      texcoord (const texcoord::type& texcoord)
      {
        this->_xsd_texcoord_.set (texcoord);
      }

      void Vertex::
      texcoord (::std::auto_ptr< texcoord::type > texcoord)
      {
        this->_xsd_texcoord_.set (texcoord);
      }


      // VertexPosition
      // 

      const VertexPosition::x::type& VertexPosition::
      x () const
      {
        return this->_xsd_x_.get ();
      }

      VertexPosition::x::type& VertexPosition::
      x ()
      {
        return this->_xsd_x_.get ();
      }

      void VertexPosition::
      x (const x::type& x)
      {
        this->_xsd_x_.set (x);
      }

      const VertexPosition::y::type& VertexPosition::
      y () const
      {
        return this->_xsd_y_.get ();
      }

      VertexPosition::y::type& VertexPosition::
      y ()
      {
        return this->_xsd_y_.get ();
      }

      void VertexPosition::
      y (const y::type& y)
      {
        this->_xsd_y_.set (y);
      }

      const VertexPosition::z::type& VertexPosition::
      z () const
      {
        return this->_xsd_z_.get ();
      }

      VertexPosition::z::type& VertexPosition::
      z ()
      {
        return this->_xsd_z_.get ();
      }

      void VertexPosition::
      z (const z::type& z)
      {
        this->_xsd_z_.set (z);
      }


      // VertexNormal
      // 

      const VertexNormal::x::type& VertexNormal::
      x () const
      {
        return this->_xsd_x_.get ();
      }

      VertexNormal::x::type& VertexNormal::
      x ()
      {
        return this->_xsd_x_.get ();
      }

      void VertexNormal::
      x (const x::type& x)
      {
        this->_xsd_x_.set (x);
      }

      const VertexNormal::y::type& VertexNormal::
      y () const
      {
        return this->_xsd_y_.get ();
      }

      VertexNormal::y::type& VertexNormal::
      y ()
      {
        return this->_xsd_y_.get ();
      }

      void VertexNormal::
      y (const y::type& y)
      {
        this->_xsd_y_.set (y);
      }

      const VertexNormal::z::type& VertexNormal::
      z () const
      {
        return this->_xsd_z_.get ();
      }

      VertexNormal::z::type& VertexNormal::
      z ()
      {
        return this->_xsd_z_.get ();
      }

      void VertexNormal::
      z (const z::type& z)
      {
        this->_xsd_z_.set (z);
      }


      // VertexTexcoord
      // 

      const VertexTexcoord::u::type& VertexTexcoord::
      u () const
      {
        return this->_xsd_u_.get ();
      }

      VertexTexcoord::u::type& VertexTexcoord::
      u ()
      {
        return this->_xsd_u_.get ();
      }

      void VertexTexcoord::
      u (const u::type& u)
      {
        this->_xsd_u_.set (u);
      }

      const VertexTexcoord::v::type& VertexTexcoord::
      v () const
      {
        return this->_xsd_v_.get ();
      }

      VertexTexcoord::v::type& VertexTexcoord::
      v ()
      {
        return this->_xsd_v_.get ();
      }

      void VertexTexcoord::
      v (const v::type& v)
      {
        this->_xsd_v_.set (v);
      }
    }
  }
}

#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/parser.hxx>

namespace ireon
{
  namespace ws
  {
    namespace navmesh_cfg
    {
      // Mesh
      //

      Mesh::
      Mesh (const submeshes::type& _xsd_submeshes)
      : ::xml_schema::type (),
      _xsd_submeshes_ (_xsd_submeshes,
                       ::xml_schema::flags (),
                       this)
      {
      }

      Mesh::
      Mesh (const Mesh& _xsd_Mesh,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
      : ::xml_schema::type (_xsd_Mesh, f, c),
      _xsd_submeshes_ (_xsd_Mesh._xsd_submeshes_,
                       f | ::xml_schema::flags::not_root,
                       this)
      {
      }

      Mesh::
      Mesh (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
      : ::xml_schema::type (e, f, c),
      _xsd_submeshes_ (f | ::xml_schema::flags::not_root, this)
      {
        parse (e, f);
      }

      void Mesh::
      parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);

        while (p.more_elements ())
        {
          const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

          // submeshes
          //
          {
            if (e.name () == "submeshes" && e.namespace_ ().empty ())
            {
              ::std::auto_ptr< submeshes::type > r (
                submeshes::traits::create (
                  e.dom_element (),
                  f | ::xml_schema::flags::not_root,
                  this));

              if (_xsd_submeshes_.present ())
                continue;
              this->submeshes (r);
              continue;
            }
          }
        }

        if (!_xsd_submeshes_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "submeshes",
            "");
        }
      }

      Mesh* Mesh::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Mesh (*this, f, c);
      }

      // Submeshes
      //

      Submeshes::
      Submeshes ()
      : ::xml_schema::type (),
      _xsd_submesh_ (::xml_schema::flags (), this)
      {
      }

      Submeshes::
      Submeshes (const Submeshes& _xsd_Submeshes,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
      : ::xml_schema::type (_xsd_Submeshes, f, c),
      _xsd_submesh_ (_xsd_Submeshes._xsd_submesh_,
                     f | ::xml_schema::flags::not_root,
                     this)
      {
      }

      Submeshes::
      Submeshes (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
      : ::xml_schema::type (e, f, c),
      _xsd_submesh_ (f | ::xml_schema::flags::not_root, this)
      {
        parse (e, f);
      }

      void Submeshes::
      parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);

        while (p.more_elements ())
        {
          const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

          // submesh
          //
          {
            if (e.name () == "submesh" && e.namespace_ ().empty ())
            {
              ::std::auto_ptr< submesh::type > r (
                submesh::traits::create (
                  e.dom_element (),
                  f | ::xml_schema::flags::not_root,
                  this));

              this->submesh ().push_back (r);
              continue;
            }
          }
        }
      }

      Submeshes* Submeshes::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Submeshes (*this, f, c);
      }

      // Submesh
      //

      Submesh::
      Submesh (const faces::type& _xsd_faces,
               const geometry::type& _xsd_geometry)
      : ::xml_schema::type (),
      _xsd_faces_ (_xsd_faces,
                   ::xml_schema::flags (),
                   this),
      _xsd_geometry_ (_xsd_geometry,
                      ::xml_schema::flags (),
                      this),
      _xsd_material_ (::xml_schema::flags (), this),
      _xsd_usesharedvertices_ (::xml_schema::flags (), this),
      _xsd_use32bitindexes_ (::xml_schema::flags (), this)
      {
      }

      Submesh::
      Submesh (const Submesh& _xsd_Submesh,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
      : ::xml_schema::type (_xsd_Submesh, f, c),
      _xsd_faces_ (_xsd_Submesh._xsd_faces_,
                   f | ::xml_schema::flags::not_root,
                   this),
      _xsd_geometry_ (_xsd_Submesh._xsd_geometry_,
                      f | ::xml_schema::flags::not_root,
                      this),
      _xsd_material_ (_xsd_Submesh._xsd_material_,
                      f | ::xml_schema::flags::not_root,
                      this),
      _xsd_usesharedvertices_ (_xsd_Submesh._xsd_usesharedvertices_,
                               f | ::xml_schema::flags::not_root,
                               this),
      _xsd_use32bitindexes_ (_xsd_Submesh._xsd_use32bitindexes_,
                             f | ::xml_schema::flags::not_root,
                             this)
      {
      }

      Submesh::
      Submesh (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
      : ::xml_schema::type (e, f, c),
      _xsd_faces_ (f | ::xml_schema::flags::not_root, this),
      _xsd_geometry_ (f | ::xml_schema::flags::not_root, this),
      _xsd_material_ (f | ::xml_schema::flags::not_root, this),
      _xsd_usesharedvertices_ (f | ::xml_schema::flags::not_root, this),
      _xsd_use32bitindexes_ (f | ::xml_schema::flags::not_root, this)
      {
        parse (e, f);
      }

      void Submesh::
      parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);

        while (p.more_elements ())
        {
          const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

          // faces
          //
          {
            if (e.name () == "faces" && e.namespace_ ().empty ())
            {
              ::std::auto_ptr< faces::type > r (
                faces::traits::create (
                  e.dom_element (),
                  f | ::xml_schema::flags::not_root,
                  this));

              if (_xsd_faces_.present ())
                continue;
              this->faces (r);
              continue;
            }
          }

          // geometry
          //
          {
            if (e.name () == "geometry" && e.namespace_ ().empty ())
            {
              ::std::auto_ptr< geometry::type > r (
                geometry::traits::create (
                  e.dom_element (),
                  f | ::xml_schema::flags::not_root,
                  this));

              if (_xsd_geometry_.present ())
                continue;
              this->geometry (r);
              continue;
            }
          }
        }

        if (!_xsd_faces_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "faces",
            "");
        }

        if (!_xsd_geometry_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "geometry",
            "");
        }

        while (p.more_attributes ())
        {
          const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

          if (a.name () == "material" && a.namespace_ ().empty ())
          {
            ::std::auto_ptr< material::type > r (
              material::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));

            this->material (r);
            continue;
          }

          if (a.name () == "usesharedvertices" && a.namespace_ ().empty ())
          {
            this->usesharedvertices (
              usesharedvertices::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }

          if (a.name () == "use32bitindexes" && a.namespace_ ().empty ())
          {
            this->use32bitindexes (
              use32bitindexes::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }
        }
      }

      Submesh* Submesh::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Submesh (*this, f, c);
      }

      // Faces
      //

      Faces::
      Faces (const count::type& _xsd_count)
      : ::xml_schema::type (),
      _xsd_face_ (::xml_schema::flags (), this),
      _xsd_count_ (_xsd_count,
                   ::xml_schema::flags (),
                   this)
      {
      }

      Faces::
      Faces (const Faces& _xsd_Faces,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
      : ::xml_schema::type (_xsd_Faces, f, c),
      _xsd_face_ (_xsd_Faces._xsd_face_,
                  f | ::xml_schema::flags::not_root,
                  this),
      _xsd_count_ (_xsd_Faces._xsd_count_,
                   f | ::xml_schema::flags::not_root,
                   this)
      {
      }

      Faces::
      Faces (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
      : ::xml_schema::type (e, f, c),
      _xsd_face_ (f | ::xml_schema::flags::not_root, this),
      _xsd_count_ (f | ::xml_schema::flags::not_root, this)
      {
        parse (e, f);
      }

      void Faces::
      parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);

        while (p.more_elements ())
        {
          const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

          // face
          //
          {
            if (e.name () == "face" && e.namespace_ ().empty ())
            {
              ::std::auto_ptr< face::type > r (
                face::traits::create (
                  e.dom_element (),
                  f | ::xml_schema::flags::not_root,
                  this));

              this->face ().push_back (r);
              continue;
            }
          }
        }

        while (p.more_attributes ())
        {
          const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

          if (a.name () == "count" && a.namespace_ ().empty ())
          {
            this->count (
              count::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }
        }

        if (!_xsd_count_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "count",
            "");
        }
      }

      Faces* Faces::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Faces (*this, f, c);
      }

      // Face
      //

      Face::
      Face (const v1::type& _xsd_v1,
            const v2::type& _xsd_v2,
            const v3::type& _xsd_v3)
      : ::xml_schema::type (),
      _xsd_v1_ (_xsd_v1,
                ::xml_schema::flags (),
                this),
      _xsd_v2_ (_xsd_v2,
                ::xml_schema::flags (),
                this),
      _xsd_v3_ (_xsd_v3,
                ::xml_schema::flags (),
                this)
      {
      }

      Face::
      Face (const Face& _xsd_Face,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
      : ::xml_schema::type (_xsd_Face, f, c),
      _xsd_v1_ (_xsd_Face._xsd_v1_,
                f | ::xml_schema::flags::not_root,
                this),
      _xsd_v2_ (_xsd_Face._xsd_v2_,
                f | ::xml_schema::flags::not_root,
                this),
      _xsd_v3_ (_xsd_Face._xsd_v3_,
                f | ::xml_schema::flags::not_root,
                this)
      {
      }

      Face::
      Face (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
      : ::xml_schema::type (e, f, c),
      _xsd_v1_ (f | ::xml_schema::flags::not_root, this),
      _xsd_v2_ (f | ::xml_schema::flags::not_root, this),
      _xsd_v3_ (f | ::xml_schema::flags::not_root, this)
      {
        parse (e, f);
      }

      void Face::
      parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);

        while (p.more_attributes ())
        {
          const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

          if (a.name () == "v1" && a.namespace_ ().empty ())
          {
            this->v1 (
              v1::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }

          if (a.name () == "v2" && a.namespace_ ().empty ())
          {
            this->v2 (
              v2::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }

          if (a.name () == "v3" && a.namespace_ ().empty ())
          {
            this->v3 (
              v3::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }
        }

        if (!_xsd_v1_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "v1",
            "");
        }

        if (!_xsd_v2_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "v2",
            "");
        }

        if (!_xsd_v3_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "v3",
            "");
        }
      }

      Face* Face::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Face (*this, f, c);
      }

      // Geometry
      //

      Geometry::
      Geometry (const vertexbuffer::type& _xsd_vertexbuffer,
                const vertexcount::type& _xsd_vertexcount)
      : ::xml_schema::type (),
      _xsd_vertexbuffer_ (_xsd_vertexbuffer,
                          ::xml_schema::flags (),
                          this),
      _xsd_vertexcount_ (_xsd_vertexcount,
                         ::xml_schema::flags (),
                         this)
      {
      }

      Geometry::
      Geometry (const Geometry& _xsd_Geometry,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::type (_xsd_Geometry, f, c),
      _xsd_vertexbuffer_ (_xsd_Geometry._xsd_vertexbuffer_,
                          f | ::xml_schema::flags::not_root,
                          this),
      _xsd_vertexcount_ (_xsd_Geometry._xsd_vertexcount_,
                         f | ::xml_schema::flags::not_root,
                         this)
      {
      }

      Geometry::
      Geometry (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::type (e, f, c),
      _xsd_vertexbuffer_ (f | ::xml_schema::flags::not_root, this),
      _xsd_vertexcount_ (f | ::xml_schema::flags::not_root, this)
      {
        parse (e, f);
      }

      void Geometry::
      parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);

        while (p.more_elements ())
        {
          const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

          // vertexbuffer
          //
          {
            if (e.name () == "vertexbuffer" && e.namespace_ ().empty ())
            {
              ::std::auto_ptr< vertexbuffer::type > r (
                vertexbuffer::traits::create (
                  e.dom_element (),
                  f | ::xml_schema::flags::not_root,
                  this));

              if (_xsd_vertexbuffer_.present ())
                continue;
              this->vertexbuffer (r);
              continue;
            }
          }
        }

        if (!_xsd_vertexbuffer_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "vertexbuffer",
            "");
        }

        while (p.more_attributes ())
        {
          const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

          if (a.name () == "vertexcount" && a.namespace_ ().empty ())
          {
            this->vertexcount (
              vertexcount::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }
        }

        if (!_xsd_vertexcount_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "vertexcount",
            "");
        }
      }

      Geometry* Geometry::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Geometry (*this, f, c);
      }

      // VertexBuffer
      //

      VertexBuffer::
      VertexBuffer ()
      : ::xml_schema::type (),
      _xsd_vertex_ (::xml_schema::flags (), this),
      _xsd_positions_ (::xml_schema::flags (), this),
      _xsd_normals_ (::xml_schema::flags (), this),
      _xsd_colours_diffuse_ (::xml_schema::flags (), this),
      _xsd_texture_coords_ (::xml_schema::flags (), this),
      _xsd_texture_coords_dimensions_0_ (::xml_schema::flags (), this)
      {
      }

      VertexBuffer::
      VertexBuffer (const VertexBuffer& _xsd_VertexBuffer,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
      : ::xml_schema::type (_xsd_VertexBuffer, f, c),
      _xsd_vertex_ (_xsd_VertexBuffer._xsd_vertex_,
                    f | ::xml_schema::flags::not_root,
                    this),
      _xsd_positions_ (_xsd_VertexBuffer._xsd_positions_,
                       f | ::xml_schema::flags::not_root,
                       this),
      _xsd_normals_ (_xsd_VertexBuffer._xsd_normals_,
                     f | ::xml_schema::flags::not_root,
                     this),
      _xsd_colours_diffuse_ (_xsd_VertexBuffer._xsd_colours_diffuse_,
                             f | ::xml_schema::flags::not_root,
                             this),
      _xsd_texture_coords_ (_xsd_VertexBuffer._xsd_texture_coords_,
                            f | ::xml_schema::flags::not_root,
                            this),
      _xsd_texture_coords_dimensions_0_ (_xsd_VertexBuffer._xsd_texture_coords_dimensions_0_,
                                         f | ::xml_schema::flags::not_root,
                                         this)
      {
      }

      VertexBuffer::
      VertexBuffer (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
      : ::xml_schema::type (e, f, c),
      _xsd_vertex_ (f | ::xml_schema::flags::not_root, this),
      _xsd_positions_ (f | ::xml_schema::flags::not_root, this),
      _xsd_normals_ (f | ::xml_schema::flags::not_root, this),
      _xsd_colours_diffuse_ (f | ::xml_schema::flags::not_root, this),
      _xsd_texture_coords_ (f | ::xml_schema::flags::not_root, this),
      _xsd_texture_coords_dimensions_0_ (f | ::xml_schema::flags::not_root, this)
      {
        parse (e, f);
      }

      void VertexBuffer::
      parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);

        while (p.more_elements ())
        {
          const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

          // vertex
          //
          {
            if (e.name () == "vertex" && e.namespace_ ().empty ())
            {
              ::std::auto_ptr< vertex::type > r (
                vertex::traits::create (
                  e.dom_element (),
                  f | ::xml_schema::flags::not_root,
                  this));

              this->vertex ().push_back (r);
              continue;
            }
          }
        }

        while (p.more_attributes ())
        {
          const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

          if (a.name () == "positions" && a.namespace_ ().empty ())
          {
            this->positions (
              positions::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }

          if (a.name () == "normals" && a.namespace_ ().empty ())
          {
            this->normals (
              normals::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }

          if (a.name () == "colours_diffuse" && a.namespace_ ().empty ())
          {
            this->colours_diffuse (
              colours_diffuse::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }

          if (a.name () == "texture_coords" && a.namespace_ ().empty ())
          {
            this->texture_coords (
              texture_coords::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }

          if (a.name () == "texture_coords_dimensions_0" && a.namespace_ ().empty ())
          {
            this->texture_coords_dimensions_0 (
              texture_coords_dimensions_0::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }
        }
      }

      VertexBuffer* VertexBuffer::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new VertexBuffer (*this, f, c);
      }

      // Vertex
      //

      Vertex::
      Vertex (const position::type& _xsd_position,
              const normal::type& _xsd_normal,
              const texcoord::type& _xsd_texcoord)
      : ::xml_schema::type (),
      _xsd_position_ (_xsd_position,
                      ::xml_schema::flags (),
                      this),
      _xsd_normal_ (_xsd_normal,
                    ::xml_schema::flags (),
                    this),
      _xsd_texcoord_ (_xsd_texcoord,
                      ::xml_schema::flags (),
                      this)
      {
      }

      Vertex::
      Vertex (const Vertex& _xsd_Vertex,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
      : ::xml_schema::type (_xsd_Vertex, f, c),
      _xsd_position_ (_xsd_Vertex._xsd_position_,
                      f | ::xml_schema::flags::not_root,
                      this),
      _xsd_normal_ (_xsd_Vertex._xsd_normal_,
                    f | ::xml_schema::flags::not_root,
                    this),
      _xsd_texcoord_ (_xsd_Vertex._xsd_texcoord_,
                      f | ::xml_schema::flags::not_root,
                      this)
      {
      }

      Vertex::
      Vertex (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
      : ::xml_schema::type (e, f, c),
      _xsd_position_ (f | ::xml_schema::flags::not_root, this),
      _xsd_normal_ (f | ::xml_schema::flags::not_root, this),
      _xsd_texcoord_ (f | ::xml_schema::flags::not_root, this)
      {
        parse (e, f);
      }

      void Vertex::
      parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);

        while (p.more_elements ())
        {
          const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

          // position
          //
          {
            if (e.name () == "position" && e.namespace_ ().empty ())
            {
              ::std::auto_ptr< position::type > r (
                position::traits::create (
                  e.dom_element (),
                  f | ::xml_schema::flags::not_root,
                  this));

              if (_xsd_position_.present ())
                continue;
              this->position (r);
              continue;
            }
          }

          // normal
          //
          {
            if (e.name () == "normal" && e.namespace_ ().empty ())
            {
              ::std::auto_ptr< normal::type > r (
                normal::traits::create (
                  e.dom_element (),
                  f | ::xml_schema::flags::not_root,
                  this));

              if (_xsd_normal_.present ())
                continue;
              this->normal (r);
              continue;
            }
          }

          // texcoord
          //
          {
            if (e.name () == "texcoord" && e.namespace_ ().empty ())
            {
              ::std::auto_ptr< texcoord::type > r (
                texcoord::traits::create (
                  e.dom_element (),
                  f | ::xml_schema::flags::not_root,
                  this));

              if (_xsd_texcoord_.present ())
                continue;
              this->texcoord (r);
              continue;
            }
          }
        }

        if (!_xsd_position_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "position",
            "");
        }

        if (!_xsd_normal_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "normal",
            "");
        }

        if (!_xsd_texcoord_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "texcoord",
            "");
        }
      }

      Vertex* Vertex::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Vertex (*this, f, c);
      }

      // VertexPosition
      //

      VertexPosition::
      VertexPosition (const x::type& _xsd_x,
                      const y::type& _xsd_y,
                      const z::type& _xsd_z)
      : ::xml_schema::type (),
      _xsd_x_ (_xsd_x,
               ::xml_schema::flags (),
               this),
      _xsd_y_ (_xsd_y,
               ::xml_schema::flags (),
               this),
      _xsd_z_ (_xsd_z,
               ::xml_schema::flags (),
               this)
      {
      }

      VertexPosition::
      VertexPosition (const VertexPosition& _xsd_VertexPosition,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::type (_xsd_VertexPosition, f, c),
      _xsd_x_ (_xsd_VertexPosition._xsd_x_,
               f | ::xml_schema::flags::not_root,
               this),
      _xsd_y_ (_xsd_VertexPosition._xsd_y_,
               f | ::xml_schema::flags::not_root,
               this),
      _xsd_z_ (_xsd_VertexPosition._xsd_z_,
               f | ::xml_schema::flags::not_root,
               this)
      {
      }

      VertexPosition::
      VertexPosition (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::type (e, f, c),
      _xsd_x_ (f | ::xml_schema::flags::not_root, this),
      _xsd_y_ (f | ::xml_schema::flags::not_root, this),
      _xsd_z_ (f | ::xml_schema::flags::not_root, this)
      {
        parse (e, f);
      }

      void VertexPosition::
      parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);

        while (p.more_attributes ())
        {
          const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

          if (a.name () == "x" && a.namespace_ ().empty ())
          {
            this->x (
              x::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }

          if (a.name () == "y" && a.namespace_ ().empty ())
          {
            this->y (
              y::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }

          if (a.name () == "z" && a.namespace_ ().empty ())
          {
            this->z (
              z::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }
        }

        if (!_xsd_x_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "x",
            "");
        }

        if (!_xsd_y_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "y",
            "");
        }

        if (!_xsd_z_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "z",
            "");
        }
      }

      VertexPosition* VertexPosition::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new VertexPosition (*this, f, c);
      }

      // VertexNormal
      //

      VertexNormal::
      VertexNormal (const x::type& _xsd_x,
                    const y::type& _xsd_y,
                    const z::type& _xsd_z)
      : ::xml_schema::type (),
      _xsd_x_ (_xsd_x,
               ::xml_schema::flags (),
               this),
      _xsd_y_ (_xsd_y,
               ::xml_schema::flags (),
               this),
      _xsd_z_ (_xsd_z,
               ::xml_schema::flags (),
               this)
      {
      }

      VertexNormal::
      VertexNormal (const VertexNormal& _xsd_VertexNormal,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
      : ::xml_schema::type (_xsd_VertexNormal, f, c),
      _xsd_x_ (_xsd_VertexNormal._xsd_x_,
               f | ::xml_schema::flags::not_root,
               this),
      _xsd_y_ (_xsd_VertexNormal._xsd_y_,
               f | ::xml_schema::flags::not_root,
               this),
      _xsd_z_ (_xsd_VertexNormal._xsd_z_,
               f | ::xml_schema::flags::not_root,
               this)
      {
      }

      VertexNormal::
      VertexNormal (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
      : ::xml_schema::type (e, f, c),
      _xsd_x_ (f | ::xml_schema::flags::not_root, this),
      _xsd_y_ (f | ::xml_schema::flags::not_root, this),
      _xsd_z_ (f | ::xml_schema::flags::not_root, this)
      {
        parse (e, f);
      }

      void VertexNormal::
      parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);

        while (p.more_attributes ())
        {
          const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

          if (a.name () == "x" && a.namespace_ ().empty ())
          {
            this->x (
              x::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }

          if (a.name () == "y" && a.namespace_ ().empty ())
          {
            this->y (
              y::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }

          if (a.name () == "z" && a.namespace_ ().empty ())
          {
            this->z (
              z::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }
        }

        if (!_xsd_x_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "x",
            "");
        }

        if (!_xsd_y_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "y",
            "");
        }

        if (!_xsd_z_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "z",
            "");
        }
      }

      VertexNormal* VertexNormal::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new VertexNormal (*this, f, c);
      }

      // VertexTexcoord
      //

      VertexTexcoord::
      VertexTexcoord (const u::type& _xsd_u,
                      const v::type& _xsd_v)
      : ::xml_schema::type (),
      _xsd_u_ (_xsd_u,
               ::xml_schema::flags (),
               this),
      _xsd_v_ (_xsd_v,
               ::xml_schema::flags (),
               this)
      {
      }

      VertexTexcoord::
      VertexTexcoord (const VertexTexcoord& _xsd_VertexTexcoord,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::type (_xsd_VertexTexcoord, f, c),
      _xsd_u_ (_xsd_VertexTexcoord._xsd_u_,
               f | ::xml_schema::flags::not_root,
               this),
      _xsd_v_ (_xsd_VertexTexcoord._xsd_v_,
               f | ::xml_schema::flags::not_root,
               this)
      {
      }

      VertexTexcoord::
      VertexTexcoord (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::type (e, f, c),
      _xsd_u_ (f | ::xml_schema::flags::not_root, this),
      _xsd_v_ (f | ::xml_schema::flags::not_root, this)
      {
        parse (e, f);
      }

      void VertexTexcoord::
      parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e);

        while (p.more_attributes ())
        {
          const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

          if (a.name () == "u" && a.namespace_ ().empty ())
          {
            this->u (
              u::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }

          if (a.name () == "v" && a.namespace_ ().empty ())
          {
            this->v (
              v::traits::create (
                a.dom_attribute (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }
        }

        if (!_xsd_u_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "u",
            "");
        }

        if (!_xsd_v_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "v",
            "");
        }
      }

      VertexTexcoord* VertexTexcoord::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new VertexTexcoord (*this, f, c);
      }
    }
  }
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace ireon
{
  namespace ws
  {
    namespace navmesh_cfg
    {
      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (const ::std::basic_string< char >& u,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::ireon::ws::navmesh_cfg::mesh (
          static_cast< const ::xercesc::DOMDocument& > (*d), f);
      }

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (const ::std::basic_string< char >& u,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

        if (!d)
        {
          throw ::xsd::cxx::tree::parsing< char > ();
        }

        return ::ireon::ws::navmesh_cfg::mesh (
          static_cast< const ::xercesc::DOMDocument& > (*d), f);
      }

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (const ::std::basic_string< char >& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

        if (!d)
        {
          throw ::xsd::cxx::tree::parsing< char > ();
        }

        return ::ireon::ws::navmesh_cfg::mesh (
          static_cast< const ::xercesc::DOMDocument& > (*d), f);
      }

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (::std::istream& is,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::ireon::ws::navmesh_cfg::mesh (wrap, f, p);
      }

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (::std::istream& is,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::ireon::ws::navmesh_cfg::mesh (wrap, h, f, p);
      }

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::ireon::ws::navmesh_cfg::mesh (wrap, h, f, p);
      }

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (::std::istream& is,
            const ::std::basic_string< char >& sid,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::ireon::ws::navmesh_cfg::mesh (wrap, f, p);
      }

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (::std::istream& is,
            const ::std::basic_string< char >& sid,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::ireon::ws::navmesh_cfg::mesh (wrap, h, f, p);
      }

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (::std::istream& is,
            const ::std::basic_string< char >& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::ireon::ws::navmesh_cfg::mesh (wrap, h, f, p);
      }

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::ireon::ws::navmesh_cfg::mesh (
          static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
      }

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (const ::xercesc::DOMInputSource& i,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

        if (!d)
        {
          throw ::xsd::cxx::tree::parsing< char > ();
        }

        return ::ireon::ws::navmesh_cfg::mesh (
          static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
      }

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

        if (!d)
        {
          throw ::xsd::cxx::tree::parsing< char > ();
        }

        return ::ireon::ws::navmesh_cfg::mesh (
          static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
      }

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >&)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          (f & ::xml_schema::flags::keep_dom) 
          ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
          : 0);

        const ::xsd::cxx::xml::dom::element< char > e (
          c.get ()
          ? *c->getDocumentElement ()
          : *d.getDocumentElement ());

        if (e.name () == "mesh" &&
            e.namespace_ () == "http://www.ireon.org/ireon/ws/navmesh_cfg/")
        {
          ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh > r (
            ::xsd::cxx::tree::traits< ::ireon::ws::navmesh_cfg::Mesh, char >::create (
              e.dom_element (), f, 0));
          if (f & ::xml_schema::flags::keep_dom) c.release ();
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          e.name (),
          e.namespace_ (),
          "mesh",
          "http://www.ireon.org/ireon/ws/navmesh_cfg/");
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/serialization.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace ireon
{
  namespace ws
  {
    namespace navmesh_cfg
    {
      void
      mesh (::xercesc::DOMDocument& d,
            const ::ireon::ws::navmesh_cfg::Mesh& s,
            ::xml_schema::flags)
      {
        ::xsd::cxx::xml::dom::element< char > e (*d.getDocumentElement ());

        if (e.name () == "mesh" &&
            e.namespace_ () == "http://www.ireon.org/ireon/ws/navmesh_cfg/")
        {
          e.dom_element () << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            e.name (),
            e.namespace_ (),
            "mesh",
            "http://www.ireon.org/ireon/ws/navmesh_cfg/");
        }
      }

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
      mesh (const ::ireon::ws::navmesh_cfg::Mesh& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xml_schema::flags f)
      {
        try
        {
          ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
            ::xsd::cxx::xml::dom::serialize< char > (
              "mesh",
              "http://www.ireon.org/ireon/ws/navmesh_cfg/",
              m,
              f));
          ::ireon::ws::navmesh_cfg::mesh (*d, s, f);
          return d;
        }
        catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
        {
          throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
        }
        catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
        {
          throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
        }
      }

      void
      mesh (::xercesc::XMLFormatTarget& t,
            const ::ireon::ws::navmesh_cfg::Mesh& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::ireon::ws::navmesh_cfg::mesh (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      mesh (::xercesc::XMLFormatTarget& t,
            const ::ireon::ws::navmesh_cfg::Mesh& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xsd::cxx::xml::error_handler< char >& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::ireon::ws::navmesh_cfg::mesh (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      mesh (::xercesc::XMLFormatTarget& t,
            const ::ireon::ws::navmesh_cfg::Mesh& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::ireon::ws::navmesh_cfg::mesh (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      mesh (::std::ostream& o,
            const ::ireon::ws::navmesh_cfg::Mesh& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0);

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::ireon::ws::navmesh_cfg::mesh (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      mesh (::std::ostream& o,
            const ::ireon::ws::navmesh_cfg::Mesh& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xsd::cxx::xml::error_handler< char >& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0);

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::ireon::ws::navmesh_cfg::mesh (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      mesh (::std::ostream& o,
            const ::ireon::ws::navmesh_cfg::Mesh& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::ireon::ws::navmesh_cfg::mesh (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e,
                  const Mesh& i)
      {
        while (::xercesc::DOMNode* n = e.getFirstChild ())
          e.removeChild (n);

        {
          ::xsd::cxx::xml::dom::element< char > s (
            "submeshes",
            e);
          s.dom_element () << i.submeshes ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e,
                  const Submeshes& i)
      {
        while (::xercesc::DOMNode* n = e.getFirstChild ())
          e.removeChild (n);

        {
          for (Submeshes::submesh::const_iterator
               b (i.submesh ().begin ()), n (i.submesh ().end ());
               b != n; ++b)
          {
            ::xsd::cxx::xml::dom::element< char > s (
              "submesh",
              e);
            s.dom_element () << *b;
          }
        }
      }

      void
      operator<< (::xercesc::DOMElement& e,
                  const Submesh& i)
      {
        while (::xercesc::DOMNode* n = e.getFirstChild ())
          e.removeChild (n);

        {
          ::xsd::cxx::xml::dom::element< char > s (
            "faces",
            e);
          s.dom_element () << i.faces ();
        }

        {
          ::xsd::cxx::xml::dom::element< char > s (
            "geometry",
            e);
          s.dom_element () << i.geometry ();
        }

        if (i.material ())
        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "material",
            e);

          a.dom_attribute () << *i.material ();
        }

        if (i.usesharedvertices ())
        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "usesharedvertices",
            e);

          a.dom_attribute () << *i.usesharedvertices ();
        }

        if (i.use32bitindexes ())
        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "use32bitindexes",
            e);

          a.dom_attribute () << *i.use32bitindexes ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e,
                  const Faces& i)
      {
        while (::xercesc::DOMNode* n = e.getFirstChild ())
          e.removeChild (n);

        {
          for (Faces::face::const_iterator
               b (i.face ().begin ()), n (i.face ().end ());
               b != n; ++b)
          {
            ::xsd::cxx::xml::dom::element< char > s (
              "face",
              e);
            s.dom_element () << *b;
          }
        }

        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "count",
            e);

          a.dom_attribute () << i.count ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e,
                  const Face& i)
      {
        while (::xercesc::DOMNode* n = e.getFirstChild ())
          e.removeChild (n);

        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "v1",
            e);

          a.dom_attribute () << i.v1 ();
        }

        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "v2",
            e);

          a.dom_attribute () << i.v2 ();
        }

        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "v3",
            e);

          a.dom_attribute () << i.v3 ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e,
                  const Geometry& i)
      {
        while (::xercesc::DOMNode* n = e.getFirstChild ())
          e.removeChild (n);

        {
          ::xsd::cxx::xml::dom::element< char > s (
            "vertexbuffer",
            e);
          s.dom_element () << i.vertexbuffer ();
        }

        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "vertexcount",
            e);

          a.dom_attribute () << i.vertexcount ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e,
                  const VertexBuffer& i)
      {
        while (::xercesc::DOMNode* n = e.getFirstChild ())
          e.removeChild (n);

        {
          for (VertexBuffer::vertex::const_iterator
               b (i.vertex ().begin ()), n (i.vertex ().end ());
               b != n; ++b)
          {
            ::xsd::cxx::xml::dom::element< char > s (
              "vertex",
              e);
            s.dom_element () << *b;
          }
        }

        if (i.positions ())
        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "positions",
            e);

          a.dom_attribute () << *i.positions ();
        }

        if (i.normals ())
        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "normals",
            e);

          a.dom_attribute () << *i.normals ();
        }

        if (i.colours_diffuse ())
        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "colours_diffuse",
            e);

          a.dom_attribute () << *i.colours_diffuse ();
        }

        if (i.texture_coords ())
        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "texture_coords",
            e);

          a.dom_attribute () << *i.texture_coords ();
        }

        if (i.texture_coords_dimensions_0 ())
        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "texture_coords_dimensions_0",
            e);

          a.dom_attribute () << *i.texture_coords_dimensions_0 ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e,
                  const Vertex& i)
      {
        while (::xercesc::DOMNode* n = e.getFirstChild ())
          e.removeChild (n);

        {
          ::xsd::cxx::xml::dom::element< char > s (
            "position",
            e);
          s.dom_element () << i.position ();
        }

        {
          ::xsd::cxx::xml::dom::element< char > s (
            "normal",
            e);
          s.dom_element () << i.normal ();
        }

        {
          ::xsd::cxx::xml::dom::element< char > s (
            "texcoord",
            e);
          s.dom_element () << i.texcoord ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e,
                  const VertexPosition& i)
      {
        while (::xercesc::DOMNode* n = e.getFirstChild ())
          e.removeChild (n);

        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "x",
            e);

          a.dom_attribute () << i.x ();
        }

        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "y",
            e);

          a.dom_attribute () << i.y ();
        }

        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "z",
            e);

          a.dom_attribute () << i.z ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e,
                  const VertexNormal& i)
      {
        while (::xercesc::DOMNode* n = e.getFirstChild ())
          e.removeChild (n);

        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "x",
            e);

          a.dom_attribute () << i.x ();
        }

        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "y",
            e);

          a.dom_attribute () << i.y ();
        }

        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "z",
            e);

          a.dom_attribute () << i.z ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e,
                  const VertexTexcoord& i)
      {
        while (::xercesc::DOMNode* n = e.getFirstChild ())
          e.removeChild (n);

        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "u",
            e);

          a.dom_attribute () << i.u ();
        }

        {
          ::xsd::cxx::xml::dom::attribute< char > a (
            "v",
            e);

          a.dom_attribute () << i.v ();
        }
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

