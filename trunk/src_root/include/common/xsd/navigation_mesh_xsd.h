// Copyright (C) 2005-2006 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// In addition, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef NAVIGATION_MESH_XSD_H
#define NAVIGATION_MESH_XSD_H

#include <xsd/cxx/version.hxx>

#if (XSD_INT_VERSION != 2030000L)
#error XSD runtime version mismatch
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "navigation_mesh_fwd_xsd.h"

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

namespace ireon
{
  namespace ws
  {
    namespace navmesh_cfg
    {
      class Mesh: public ::xml_schema::type
      {
        public:

        struct _xsd_Mesh
        {
          typedef ::xml_schema::type base_;
        };

        // submeshes
        // 
        public:
        struct submeshes
        {
          typedef ::ireon::ws::navmesh_cfg::Submeshes type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const submeshes::type&
        submeshes () const;

        submeshes::type&
        submeshes ();

        void
        submeshes (const submeshes::type&);

        void
        submeshes (::std::auto_ptr< submeshes::type >);

        // Constructors.
        //
        public:
        Mesh (const submeshes::type&);

        Mesh (const ::xercesc::DOMElement&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

        Mesh (const Mesh&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

        virtual Mesh*
        _clone (::xml_schema::flags = 0,
                ::xml_schema::type* = 0) const;

        // Implementation.
        //
        private:
        void
        parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

        ::xsd::cxx::tree::one< submeshes::type > _xsd_submeshes_;
      };

      class Submeshes: public ::xml_schema::type
      {
        public:

        struct _xsd_Submeshes
        {
          typedef ::xml_schema::type base_;
        };

        // submesh
        // 
        public:
        struct submesh
        {
          typedef ::ireon::ws::navmesh_cfg::Submesh type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const submesh::type&
        submesh () const;

        submesh::type&
        submesh ();

        void
        submesh (const submesh::type&);

        void
        submesh (::std::auto_ptr< submesh::type >);

        // Constructors.
        //
        public:
        Submeshes (const submesh::type&);

        Submeshes (const ::xercesc::DOMElement&,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

        Submeshes (const Submeshes&,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

        virtual Submeshes*
        _clone (::xml_schema::flags = 0,
                ::xml_schema::type* = 0) const;

        // Implementation.
        //
        private:
        void
        parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

        ::xsd::cxx::tree::one< submesh::type > _xsd_submesh_;
      };

      class Submesh: public ::xml_schema::type
      {
        public:

        struct _xsd_Submesh
        {
          typedef ::xml_schema::type base_;
        };

        // faces
        // 
        public:
        struct faces
        {
          typedef ::ireon::ws::navmesh_cfg::Faces type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const faces::type&
        faces () const;

        faces::type&
        faces ();

        void
        faces (const faces::type&);

        void
        faces (::std::auto_ptr< faces::type >);

        // geometry
        // 
        public:
        struct geometry
        {
          typedef ::ireon::ws::navmesh_cfg::Geometry type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const geometry::type&
        geometry () const;

        geometry::type&
        geometry ();

        void
        geometry (const geometry::type&);

        void
        geometry (::std::auto_ptr< geometry::type >);

        // material
        // 
        public:
        struct material
        {
          typedef ::xml_schema::normalized_string type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
          typedef ::xsd::cxx::tree::optional< type > container;
        };

        const material::container&
        material () const;

        material::container&
        material ();

        void
        material (const material::type&);

        void
        material (const material::container&);

        void
        material (::std::auto_ptr< material::type >);

        // usesharedvertices
        // 
        public:
        struct usesharedvertices
        {
          typedef ::xml_schema::boolean type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
          typedef ::xsd::cxx::tree::optional< type > container;
        };

        const usesharedvertices::container&
        usesharedvertices () const;

        usesharedvertices::container&
        usesharedvertices ();

        void
        usesharedvertices (const usesharedvertices::type&);

        void
        usesharedvertices (const usesharedvertices::container&);

        // use32bitindexes
        // 
        public:
        struct use32bitindexes
        {
          typedef ::xml_schema::boolean type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
          typedef ::xsd::cxx::tree::optional< type > container;
        };

        const use32bitindexes::container&
        use32bitindexes () const;

        use32bitindexes::container&
        use32bitindexes ();

        void
        use32bitindexes (const use32bitindexes::type&);

        void
        use32bitindexes (const use32bitindexes::container&);

        // Constructors.
        //
        public:
        Submesh (const faces::type&,
                 const geometry::type&);

        Submesh (const ::xercesc::DOMElement&,
                 ::xml_schema::flags = 0,
                 ::xml_schema::type* = 0);

        Submesh (const Submesh&,
                 ::xml_schema::flags = 0,
                 ::xml_schema::type* = 0);

        virtual Submesh*
        _clone (::xml_schema::flags = 0,
                ::xml_schema::type* = 0) const;

        // Implementation.
        //
        private:
        void
        parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

        ::xsd::cxx::tree::one< faces::type > _xsd_faces_;
        ::xsd::cxx::tree::one< geometry::type > _xsd_geometry_;
        ::xsd::cxx::tree::optional< material::type > _xsd_material_;
        ::xsd::cxx::tree::optional< usesharedvertices::type > _xsd_usesharedvertices_;
        ::xsd::cxx::tree::optional< use32bitindexes::type > _xsd_use32bitindexes_;
      };

      class Faces: public ::xml_schema::type
      {
        public:

        struct _xsd_Faces
        {
          typedef ::xml_schema::type base_;
        };

        // face
        // 
        public:
        struct face
        {
          typedef ::ireon::ws::navmesh_cfg::Face type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
          typedef ::xsd::cxx::tree::sequence< type > container;
          typedef container::iterator iterator;
          typedef container::const_iterator const_iterator;
        };

        const face::container&
        face () const;

        face::container&
        face ();

        void
        face (const face::container&);

        // count
        // 
        public:
        struct count
        {
          typedef ::xml_schema::unsigned_int type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const count::type&
        count () const;

        count::type&
        count ();

        void
        count (const count::type&);

        // Constructors.
        //
        public:
        Faces (const count::type&);

        Faces (const ::xercesc::DOMElement&,
               ::xml_schema::flags = 0,
               ::xml_schema::type* = 0);

        Faces (const Faces&,
               ::xml_schema::flags = 0,
               ::xml_schema::type* = 0);

        virtual Faces*
        _clone (::xml_schema::flags = 0,
                ::xml_schema::type* = 0) const;

        // Implementation.
        //
        private:
        void
        parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

        ::xsd::cxx::tree::sequence< face::type > _xsd_face_;
        ::xsd::cxx::tree::one< count::type > _xsd_count_;
      };

      class Face: public ::xml_schema::type
      {
        public:

        struct _xsd_Face
        {
          typedef ::xml_schema::type base_;
        };

        // v1
        // 
        public:
        struct v1
        {
          typedef ::xml_schema::unsigned_int type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const v1::type&
        v1 () const;

        v1::type&
        v1 ();

        void
        v1 (const v1::type&);

        // v2
        // 
        public:
        struct v2
        {
          typedef ::xml_schema::unsigned_int type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const v2::type&
        v2 () const;

        v2::type&
        v2 ();

        void
        v2 (const v2::type&);

        // v3
        // 
        public:
        struct v3
        {
          typedef ::xml_schema::unsigned_int type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const v3::type&
        v3 () const;

        v3::type&
        v3 ();

        void
        v3 (const v3::type&);

        // Constructors.
        //
        public:
        Face (const v1::type&,
              const v2::type&,
              const v3::type&);

        Face (const ::xercesc::DOMElement&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

        Face (const Face&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

        virtual Face*
        _clone (::xml_schema::flags = 0,
                ::xml_schema::type* = 0) const;

        // Implementation.
        //
        private:
        void
        parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

        ::xsd::cxx::tree::one< v1::type > _xsd_v1_;
        ::xsd::cxx::tree::one< v2::type > _xsd_v2_;
        ::xsd::cxx::tree::one< v3::type > _xsd_v3_;
      };

      class Geometry: public ::xml_schema::type
      {
        public:

        struct _xsd_Geometry
        {
          typedef ::xml_schema::type base_;
        };

        // vertexbuffer
        // 
        public:
        struct vertexbuffer
        {
          typedef ::ireon::ws::navmesh_cfg::VertexBuffer type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const vertexbuffer::type&
        vertexbuffer () const;

        vertexbuffer::type&
        vertexbuffer ();

        void
        vertexbuffer (const vertexbuffer::type&);

        void
        vertexbuffer (::std::auto_ptr< vertexbuffer::type >);

        // vertexcount
        // 
        public:
        struct vertexcount
        {
          typedef ::xml_schema::unsigned_int type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const vertexcount::type&
        vertexcount () const;

        vertexcount::type&
        vertexcount ();

        void
        vertexcount (const vertexcount::type&);

        // Constructors.
        //
        public:
        Geometry (const vertexbuffer::type&,
                  const vertexcount::type&);

        Geometry (const ::xercesc::DOMElement&,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

        Geometry (const Geometry&,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

        virtual Geometry*
        _clone (::xml_schema::flags = 0,
                ::xml_schema::type* = 0) const;

        // Implementation.
        //
        private:
        void
        parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

        ::xsd::cxx::tree::one< vertexbuffer::type > _xsd_vertexbuffer_;
        ::xsd::cxx::tree::one< vertexcount::type > _xsd_vertexcount_;
      };

      class VertexBuffer: public ::xml_schema::type
      {
        public:

        struct _xsd_VertexBuffer
        {
          typedef ::xml_schema::type base_;
        };

        // vertex
        // 
        public:
        struct vertex
        {
          typedef ::ireon::ws::navmesh_cfg::Vertex type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
          typedef ::xsd::cxx::tree::sequence< type > container;
          typedef container::iterator iterator;
          typedef container::const_iterator const_iterator;
        };

        const vertex::container&
        vertex () const;

        vertex::container&
        vertex ();

        void
        vertex (const vertex::container&);

        // positions
        // 
        public:
        struct positions
        {
          typedef ::xml_schema::boolean type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
          typedef ::xsd::cxx::tree::optional< type > container;
        };

        const positions::container&
        positions () const;

        positions::container&
        positions ();

        void
        positions (const positions::type&);

        void
        positions (const positions::container&);

        // normals
        // 
        public:
        struct normals
        {
          typedef ::xml_schema::boolean type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
          typedef ::xsd::cxx::tree::optional< type > container;
        };

        const normals::container&
        normals () const;

        normals::container&
        normals ();

        void
        normals (const normals::type&);

        void
        normals (const normals::container&);

        // colours_diffuse
        // 
        public:
        struct colours_diffuse
        {
          typedef ::xml_schema::boolean type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
          typedef ::xsd::cxx::tree::optional< type > container;
        };

        const colours_diffuse::container&
        colours_diffuse () const;

        colours_diffuse::container&
        colours_diffuse ();

        void
        colours_diffuse (const colours_diffuse::type&);

        void
        colours_diffuse (const colours_diffuse::container&);

        // texture_coords
        // 
        public:
        struct texture_coords
        {
          typedef ::xml_schema::unsigned_int type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
          typedef ::xsd::cxx::tree::optional< type > container;
        };

        const texture_coords::container&
        texture_coords () const;

        texture_coords::container&
        texture_coords ();

        void
        texture_coords (const texture_coords::type&);

        void
        texture_coords (const texture_coords::container&);

        // texture_coords_dimensions_0
        // 
        public:
        struct texture_coords_dimensions_0
        {
          typedef ::xml_schema::unsigned_int type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
          typedef ::xsd::cxx::tree::optional< type > container;
        };

        const texture_coords_dimensions_0::container&
        texture_coords_dimensions_0 () const;

        texture_coords_dimensions_0::container&
        texture_coords_dimensions_0 ();

        void
        texture_coords_dimensions_0 (const texture_coords_dimensions_0::type&);

        void
        texture_coords_dimensions_0 (const texture_coords_dimensions_0::container&);

        // Constructors.
        //
        public:
        VertexBuffer ();

        VertexBuffer (const ::xercesc::DOMElement&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

        VertexBuffer (const VertexBuffer&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

        virtual VertexBuffer*
        _clone (::xml_schema::flags = 0,
                ::xml_schema::type* = 0) const;

        // Implementation.
        //
        private:
        void
        parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

        ::xsd::cxx::tree::sequence< vertex::type > _xsd_vertex_;
        ::xsd::cxx::tree::optional< positions::type > _xsd_positions_;
        ::xsd::cxx::tree::optional< normals::type > _xsd_normals_;
        ::xsd::cxx::tree::optional< colours_diffuse::type > _xsd_colours_diffuse_;
        ::xsd::cxx::tree::optional< texture_coords::type > _xsd_texture_coords_;
        ::xsd::cxx::tree::optional< texture_coords_dimensions_0::type > _xsd_texture_coords_dimensions_0_;
      };

      class Vertex: public ::xml_schema::type
      {
        public:

        struct _xsd_Vertex
        {
          typedef ::xml_schema::type base_;
        };

        // position
        // 
        public:
        struct position
        {
          typedef ::ireon::ws::navmesh_cfg::VertexPosition type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const position::type&
        position () const;

        position::type&
        position ();

        void
        position (const position::type&);

        void
        position (::std::auto_ptr< position::type >);

        // normal
        // 
        public:
        struct normal
        {
          typedef ::ireon::ws::navmesh_cfg::VertexNormal type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const normal::type&
        normal () const;

        normal::type&
        normal ();

        void
        normal (const normal::type&);

        void
        normal (::std::auto_ptr< normal::type >);

        // texcoord
        // 
        public:
        struct texcoord
        {
          typedef ::ireon::ws::navmesh_cfg::VertexTexcoord type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const texcoord::type&
        texcoord () const;

        texcoord::type&
        texcoord ();

        void
        texcoord (const texcoord::type&);

        void
        texcoord (::std::auto_ptr< texcoord::type >);

        // Constructors.
        //
        public:
        Vertex (const position::type&,
                const normal::type&,
                const texcoord::type&);

        Vertex (const ::xercesc::DOMElement&,
                ::xml_schema::flags = 0,
                ::xml_schema::type* = 0);

        Vertex (const Vertex&,
                ::xml_schema::flags = 0,
                ::xml_schema::type* = 0);

        virtual Vertex*
        _clone (::xml_schema::flags = 0,
                ::xml_schema::type* = 0) const;

        // Implementation.
        //
        private:
        void
        parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

        ::xsd::cxx::tree::one< position::type > _xsd_position_;
        ::xsd::cxx::tree::one< normal::type > _xsd_normal_;
        ::xsd::cxx::tree::one< texcoord::type > _xsd_texcoord_;
      };

      class VertexPosition: public ::xml_schema::type
      {
        public:

        struct _xsd_VertexPosition
        {
          typedef ::xml_schema::type base_;
        };

        // x
        // 
        public:
        struct x
        {
          typedef ::xml_schema::float_ type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const x::type&
        x () const;

        x::type&
        x ();

        void
        x (const x::type&);

        // y
        // 
        public:
        struct y
        {
          typedef ::xml_schema::float_ type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const y::type&
        y () const;

        y::type&
        y ();

        void
        y (const y::type&);

        // z
        // 
        public:
        struct z
        {
          typedef ::xml_schema::float_ type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const z::type&
        z () const;

        z::type&
        z ();

        void
        z (const z::type&);

        // Constructors.
        //
        public:
        VertexPosition (const x::type&,
                        const y::type&,
                        const z::type&);

        VertexPosition (const ::xercesc::DOMElement&,
                        ::xml_schema::flags = 0,
                        ::xml_schema::type* = 0);

        VertexPosition (const VertexPosition&,
                        ::xml_schema::flags = 0,
                        ::xml_schema::type* = 0);

        virtual VertexPosition*
        _clone (::xml_schema::flags = 0,
                ::xml_schema::type* = 0) const;

        // Implementation.
        //
        private:
        void
        parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

        ::xsd::cxx::tree::one< x::type > _xsd_x_;
        ::xsd::cxx::tree::one< y::type > _xsd_y_;
        ::xsd::cxx::tree::one< z::type > _xsd_z_;
      };

      class VertexNormal: public ::xml_schema::type
      {
        public:

        struct _xsd_VertexNormal
        {
          typedef ::xml_schema::type base_;
        };

        // x
        // 
        public:
        struct x
        {
          typedef ::xml_schema::float_ type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const x::type&
        x () const;

        x::type&
        x ();

        void
        x (const x::type&);

        // y
        // 
        public:
        struct y
        {
          typedef ::xml_schema::float_ type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const y::type&
        y () const;

        y::type&
        y ();

        void
        y (const y::type&);

        // z
        // 
        public:
        struct z
        {
          typedef ::xml_schema::float_ type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const z::type&
        z () const;

        z::type&
        z ();

        void
        z (const z::type&);

        // Constructors.
        //
        public:
        VertexNormal (const x::type&,
                      const y::type&,
                      const z::type&);

        VertexNormal (const ::xercesc::DOMElement&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

        VertexNormal (const VertexNormal&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

        virtual VertexNormal*
        _clone (::xml_schema::flags = 0,
                ::xml_schema::type* = 0) const;

        // Implementation.
        //
        private:
        void
        parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

        ::xsd::cxx::tree::one< x::type > _xsd_x_;
        ::xsd::cxx::tree::one< y::type > _xsd_y_;
        ::xsd::cxx::tree::one< z::type > _xsd_z_;
      };

      class VertexTexcoord: public ::xml_schema::type
      {
        public:

        struct _xsd_VertexTexcoord
        {
          typedef ::xml_schema::type base_;
        };

        // u
        // 
        public:
        struct u
        {
          typedef ::xml_schema::float_ type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const u::type&
        u () const;

        u::type&
        u ();

        void
        u (const u::type&);

        // v
        // 
        public:
        struct v
        {
          typedef ::xml_schema::float_ type;
          typedef ::xsd::cxx::tree::traits< type, char > traits;
        };

        const v::type&
        v () const;

        v::type&
        v ();

        void
        v (const v::type&);

        // Constructors.
        //
        public:
        VertexTexcoord (const u::type&,
                        const v::type&);

        VertexTexcoord (const ::xercesc::DOMElement&,
                        ::xml_schema::flags = 0,
                        ::xml_schema::type* = 0);

        VertexTexcoord (const VertexTexcoord&,
                        ::xml_schema::flags = 0,
                        ::xml_schema::type* = 0);

        virtual VertexTexcoord*
        _clone (::xml_schema::flags = 0,
                ::xml_schema::type* = 0) const;

        // Implementation.
        //
        private:
        void
        parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

        ::xsd::cxx::tree::one< u::type > _xsd_u_;
        ::xsd::cxx::tree::one< v::type > _xsd_v_;
      };
    }
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMInputSource.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

#include <xsd/cxx/tree/parsing.hxx>

namespace ireon
{
  namespace ws
  {
    namespace navmesh_cfg
    {
      // Read from a URI or a local file.
      //

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (const ::std::basic_string< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (const ::std::basic_string< char >&,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (const ::std::basic_string< char >&,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


      // Read from std::istream.
      //

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (::std::istream&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (::std::istream&,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (::std::istream&,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (::std::istream&,
            const ::std::basic_string< char >& id,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (::std::istream&,
            const ::std::basic_string< char >& id,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (::std::istream&,
            const ::std::basic_string< char >& id,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


      // Read from InputSource.
      //

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (const ::xercesc::DOMInputSource&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (const ::xercesc::DOMInputSource&,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (const ::xercesc::DOMInputSource&,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


      // Read from DOM.
      //

      ::std::auto_ptr< ::ireon::ws::navmesh_cfg::Mesh >
      mesh (const ::xercesc::DOMDocument&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());
    }
  }
}

#include <iosfwd> // std::ostream&

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>
#include <xsd/cxx/tree/serialization.hxx>

namespace ireon
{
  namespace ws
  {
    namespace navmesh_cfg
    {
      // Serialize to an existing DOM instance.
      //
      void
      mesh (::xercesc::DOMDocument&,
            const ::ireon::ws::navmesh_cfg::Mesh&,
            ::xml_schema::flags = 0);


      // Serialize to a new DOM instance.
      //
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
      mesh (const ::ireon::ws::navmesh_cfg::Mesh&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xml_schema::flags = 0);


      // Serialize to XMLFormatTarget.
      //
      void
      mesh (::xercesc::XMLFormatTarget&,
            const ::ireon::ws::navmesh_cfg::Mesh&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


      void
      mesh (::xercesc::XMLFormatTarget&,
            const ::ireon::ws::navmesh_cfg::Mesh&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xsd::cxx::xml::error_handler< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);

      void
      mesh (::xercesc::XMLFormatTarget&,
            const ::ireon::ws::navmesh_cfg::Mesh&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xercesc::DOMErrorHandler&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


      // Serialize to std::ostream.
      //
      void
      mesh (::std::ostream&,
            const ::ireon::ws::navmesh_cfg::Mesh&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


      void
      mesh (::std::ostream&,
            const ::ireon::ws::navmesh_cfg::Mesh&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xsd::cxx::xml::error_handler< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);

      void
      mesh (::std::ostream&,
            const ::ireon::ws::navmesh_cfg::Mesh&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xercesc::DOMErrorHandler&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


      void
      operator<< (::xercesc::DOMElement&,
                  const Mesh&);

      void
      operator<< (::xercesc::DOMElement&,
                  const Submeshes&);

      void
      operator<< (::xercesc::DOMElement&,
                  const Submesh&);

      void
      operator<< (::xercesc::DOMElement&,
                  const Faces&);

      void
      operator<< (::xercesc::DOMElement&,
                  const Face&);

      void
      operator<< (::xercesc::DOMElement&,
                  const Geometry&);

      void
      operator<< (::xercesc::DOMElement&,
                  const VertexBuffer&);

      void
      operator<< (::xercesc::DOMElement&,
                  const Vertex&);

      void
      operator<< (::xercesc::DOMElement&,
                  const VertexPosition&);

      void
      operator<< (::xercesc::DOMElement&,
                  const VertexNormal&);

      void
      operator<< (::xercesc::DOMElement&,
                  const VertexTexcoord&);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // NAVIGATION_MESH_XSD_H
