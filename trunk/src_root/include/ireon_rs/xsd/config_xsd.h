// Copyright (C) 2005-2006 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// In addition, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CONFIG_XSD_H
#define CONFIG_XSD_H

#include <xsd/cxx/version.hxx>

#if (XSD_INT_VERSION != 2030000L)
#error XSD runtime version mismatch
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "config_fwd_xsd.h"

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

namespace ireon
{
  namespace rs
  {
    class CRSConfig: public ::xml_schema::type
    {
      public:

      struct _xsd_CRSConfig
      {
        typedef ::xml_schema::type base_;
      };

      // requiredClientVersion
      // 
      public:
      struct requiredClientVersion
      {
        typedef ::ireon::rs::CClientVersion type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const requiredClientVersion::container&
      requiredClientVersion () const;

      requiredClientVersion::container&
      requiredClientVersion ();

      void
      requiredClientVersion (const requiredClientVersion::type&);

      void
      requiredClientVersion (const requiredClientVersion::container&);

      void
      requiredClientVersion (::std::auto_ptr< requiredClientVersion::type >);

      // playerConnectionsListener
      // 
      public:
      struct playerConnectionsListener
      {
        typedef ::ireon::rs::CPlayerListener type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const playerConnectionsListener::container&
      playerConnectionsListener () const;

      playerConnectionsListener::container&
      playerConnectionsListener ();

      void
      playerConnectionsListener (const playerConnectionsListener::type&);

      void
      playerConnectionsListener (const playerConnectionsListener::container&);

      void
      playerConnectionsListener (::std::auto_ptr< playerConnectionsListener::type >);

      // wsConnectionsListener
      // 
      public:
      struct wsConnectionsListener
      {
        typedef ::ireon::rs::CWSListener type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const wsConnectionsListener::container&
      wsConnectionsListener () const;

      wsConnectionsListener::container&
      wsConnectionsListener ();

      void
      wsConnectionsListener (const wsConnectionsListener::type&);

      void
      wsConnectionsListener (const wsConnectionsListener::container&);

      void
      wsConnectionsListener (::std::auto_ptr< wsConnectionsListener::type >);

      // db
      // 
      public:
      struct db
      {
        typedef ::ireon::rs::CDBconnection type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const db::type&
      db () const;

      db::type&
      db ();

      void
      db (const db::type&);

      void
      db (::std::auto_ptr< db::type >);

      // Constructors.
      //
      public:
      CRSConfig (const db::type&);

      CRSConfig (const ::xercesc::DOMElement&,
                 ::xml_schema::flags = 0,
                 ::xml_schema::type* = 0);

      CRSConfig (const CRSConfig&,
                 ::xml_schema::flags = 0,
                 ::xml_schema::type* = 0);

      virtual CRSConfig*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< requiredClientVersion::type > _xsd_requiredClientVersion_;
      ::xsd::cxx::tree::optional< playerConnectionsListener::type > _xsd_playerConnectionsListener_;
      ::xsd::cxx::tree::optional< wsConnectionsListener::type > _xsd_wsConnectionsListener_;
      ::xsd::cxx::tree::one< db::type > _xsd_db_;
    };

    class CPlayerListener: public ::xml_schema::type
    {
      public:

      struct _xsd_CPlayerListener
      {
        typedef ::xml_schema::type base_;
      };

      // port
      // 
      public:
      struct port
      {
        typedef ::ireon::rs::CPort type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const port::container&
      port () const;

      port::container&
      port ();

      void
      port (const port::type&);

      void
      port (const port::container&);

      void
      port (::std::auto_ptr< port::type >);

      // maxConnections
      // 
      public:
      struct maxConnections
      {
        typedef ::ireon::rs::CConnectionsNumber type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const maxConnections::container&
      maxConnections () const;

      maxConnections::container&
      maxConnections ();

      void
      maxConnections (const maxConnections::type&);

      void
      maxConnections (const maxConnections::container&);

      void
      maxConnections (::std::auto_ptr< maxConnections::type >);

      // Constructors.
      //
      public:
      CPlayerListener ();

      CPlayerListener (const ::xercesc::DOMElement&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      CPlayerListener (const CPlayerListener&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      virtual CPlayerListener*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< port::type > _xsd_port_;
      ::xsd::cxx::tree::optional< maxConnections::type > _xsd_maxConnections_;
    };

    class CWSListener: public ::xml_schema::type
    {
      public:

      struct _xsd_CWSListener
      {
        typedef ::xml_schema::type base_;
      };

      // port
      // 
      public:
      struct port
      {
        typedef ::ireon::rs::CPort type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const port::container&
      port () const;

      port::container&
      port ();

      void
      port (const port::type&);

      void
      port (const port::container&);

      void
      port (::std::auto_ptr< port::type >);

      // maxConnections
      // 
      public:
      struct maxConnections
      {
        typedef ::ireon::rs::CConnectionsNumber type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const maxConnections::container&
      maxConnections () const;

      maxConnections::container&
      maxConnections ();

      void
      maxConnections (const maxConnections::type&);

      void
      maxConnections (const maxConnections::container&);

      void
      maxConnections (::std::auto_ptr< maxConnections::type >);

      // Constructors.
      //
      public:
      CWSListener ();

      CWSListener (const ::xercesc::DOMElement&,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

      CWSListener (const CWSListener&,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

      virtual CWSListener*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< port::type > _xsd_port_;
      ::xsd::cxx::tree::optional< maxConnections::type > _xsd_maxConnections_;
    };

    class CClientVersion: public ::xml_schema::type
    {
      public:

      struct _xsd_CClientVersion
      {
        typedef ::xml_schema::type base_;
      };

      // major
      // 
      public:
      struct major
      {
        typedef ::xml_schema::unsigned_byte type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const major::type&
      major () const;

      major::type&
      major ();

      void
      major (const major::type&);

      // minor
      // 
      public:
      struct minor
      {
        typedef ::xml_schema::unsigned_byte type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const minor::type&
      minor () const;

      minor::type&
      minor ();

      void
      minor (const minor::type&);

      // release
      // 
      public:
      struct release
      {
        typedef ::xml_schema::unsigned_short type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const release::type&
      release () const;

      release::type&
      release ();

      void
      release (const release::type&);

      // build
      // 
      public:
      struct build
      {
        typedef ::xml_schema::unsigned_short type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const build::type&
      build () const;

      build::type&
      build ();

      void
      build (const build::type&);

      // Constructors.
      //
      public:
      CClientVersion (const major::type&,
                      const minor::type&,
                      const release::type&,
                      const build::type&);

      CClientVersion (const ::xercesc::DOMElement&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

      CClientVersion (const CClientVersion&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

      virtual CClientVersion*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< major::type > _xsd_major_;
      ::xsd::cxx::tree::one< minor::type > _xsd_minor_;
      ::xsd::cxx::tree::one< release::type > _xsd_release_;
      ::xsd::cxx::tree::one< build::type > _xsd_build_;
    };

    class CDBconnection: public ::xml_schema::type
    {
      public:

      struct _xsd_CDBconnection
      {
        typedef ::xml_schema::type base_;
      };

      // ip
      // 
      public:
      struct ip
      {
        typedef ::ireon::rs::CIPv4Address type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const ip::container&
      ip () const;

      ip::container&
      ip ();

      void
      ip (const ip::type&);

      void
      ip (const ip::container&);

      void
      ip (::std::auto_ptr< ip::type >);

      // port
      // 
      public:
      struct port
      {
        typedef ::ireon::rs::CPort type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const port::container&
      port () const;

      port::container&
      port ();

      void
      port (const port::type&);

      void
      port (const port::container&);

      void
      port (::std::auto_ptr< port::type >);

      // login
      // 
      public:
      struct login
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const login::type&
      login () const;

      login::type&
      login ();

      void
      login (const login::type&);

      void
      login (::std::auto_ptr< login::type >);

      // password
      // 
      public:
      struct password
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const password::type&
      password () const;

      password::type&
      password ();

      void
      password (const password::type&);

      void
      password (::std::auto_ptr< password::type >);

      // schema
      // 
      public:
      struct schema
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const schema::container&
      schema () const;

      schema::container&
      schema ();

      void
      schema (const schema::type&);

      void
      schema (const schema::container&);

      void
      schema (::std::auto_ptr< schema::type >);

      // Constructors.
      //
      public:
      CDBconnection (const login::type&,
                     const password::type&);

      CDBconnection (const ::xercesc::DOMElement&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      CDBconnection (const CDBconnection&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      virtual CDBconnection*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< ip::type > _xsd_ip_;
      ::xsd::cxx::tree::optional< port::type > _xsd_port_;
      ::xsd::cxx::tree::one< login::type > _xsd_login_;
      ::xsd::cxx::tree::one< password::type > _xsd_password_;
      ::xsd::cxx::tree::optional< schema::type > _xsd_schema_;
    };

    class CIPv4Address: public ::xml_schema::string
    {
      public:

      struct _xsd_CIPv4Address
      {
        typedef ::xml_schema::string base_;
      };

      // Constructors.
      //
      public:
      CIPv4Address (const _xsd_CIPv4Address::base_& );

      CIPv4Address (const ::xercesc::DOMElement&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      CIPv4Address (const ::xercesc::DOMAttr&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      CIPv4Address (const ::std::basic_string< char >&,
                    const ::xercesc::DOMElement*,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      CIPv4Address (const CIPv4Address&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      virtual CIPv4Address*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;
    };

    class CPort: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >
    {
      public:

      struct _xsd_CPort
      {
        typedef ::xml_schema::unsigned_short base_;
      };

      // Constructors.
      //
      public:
      CPort (const _xsd_CPort::base_& );

      CPort (const ::xercesc::DOMElement&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

      CPort (const ::xercesc::DOMAttr&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

      CPort (const ::std::basic_string< char >&,
             const ::xercesc::DOMElement*,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

      CPort (const CPort&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

      virtual CPort*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;
    };

    class CConnectionsNumber: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type >
    {
      public:

      struct _xsd_CConnectionsNumber
      {
        typedef ::xml_schema::unsigned_byte base_;
      };

      // Constructors.
      //
      public:
      CConnectionsNumber (const _xsd_CConnectionsNumber::base_& );

      CConnectionsNumber (const ::xercesc::DOMElement&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      CConnectionsNumber (const ::xercesc::DOMAttr&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      CConnectionsNumber (const ::std::basic_string< char >&,
                          const ::xercesc::DOMElement*,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      CConnectionsNumber (const CConnectionsNumber&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      virtual CConnectionsNumber*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;
    };
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMInputSource.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

#include <xsd/cxx/tree/parsing.hxx>

namespace ireon
{
  namespace rs
  {
    // Read from a URI or a local file.
    //

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (const ::std::basic_string< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (const ::std::basic_string< char >&,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (const ::std::basic_string< char >&,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    // Read from std::istream.
    //

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (::std::istream&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (::std::istream&,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (::std::istream&,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (::std::istream&,
            const ::std::basic_string< char >& id,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (::std::istream&,
            const ::std::basic_string< char >& id,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (::std::istream&,
            const ::std::basic_string< char >& id,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    // Read from InputSource.
    //

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (const ::xercesc::DOMInputSource&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (const ::xercesc::DOMInputSource&,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (const ::xercesc::DOMInputSource&,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    // Read from DOM.
    //

    ::std::auto_ptr< ::ireon::rs::CRSConfig >
    config (const ::xercesc::DOMDocument&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());
  }
}

#include <iosfwd> // std::ostream&

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>
#include <xsd/cxx/tree/serialization.hxx>

namespace ireon
{
  namespace rs
  {
    // Serialize to an existing DOM instance.
    //
    void
    config (::xercesc::DOMDocument&,
            const ::ireon::rs::CRSConfig&,
            ::xml_schema::flags = 0);


    // Serialize to a new DOM instance.
    //
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    config (const ::ireon::rs::CRSConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xml_schema::flags = 0);


    // Serialize to XMLFormatTarget.
    //
    void
    config (::xercesc::XMLFormatTarget&,
            const ::ireon::rs::CRSConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


    void
    config (::xercesc::XMLFormatTarget&,
            const ::ireon::rs::CRSConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xsd::cxx::xml::error_handler< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);

    void
    config (::xercesc::XMLFormatTarget&,
            const ::ireon::rs::CRSConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xercesc::DOMErrorHandler&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


    // Serialize to std::ostream.
    //
    void
    config (::std::ostream&,
            const ::ireon::rs::CRSConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


    void
    config (::std::ostream&,
            const ::ireon::rs::CRSConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xsd::cxx::xml::error_handler< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);

    void
    config (::std::ostream&,
            const ::ireon::rs::CRSConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xercesc::DOMErrorHandler&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


    void
    operator<< (::xercesc::DOMElement&,
                const CRSConfig&);

    void
    operator<< (::xercesc::DOMElement&,
                const CPlayerListener&);

    void
    operator<< (::xercesc::DOMElement&,
                const CWSListener&);

    void
    operator<< (::xercesc::DOMElement&,
                const CClientVersion&);

    void
    operator<< (::xercesc::DOMElement&,
                const CDBconnection&);

    void
    operator<< (::xercesc::DOMElement&,
                const CIPv4Address&);

    void
    operator<< (::xercesc::DOMAttr&,
                const CIPv4Address&);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                const CIPv4Address&);

    void
    operator<< (::xercesc::DOMElement&,
                const CPort&);

    void
    operator<< (::xercesc::DOMAttr&,
                const CPort&);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                const CPort&);

    void
    operator<< (::xercesc::DOMElement&,
                const CConnectionsNumber&);

    void
    operator<< (::xercesc::DOMAttr&,
                const CConnectionsNumber&);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                const CConnectionsNumber&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CONFIG_XSD_H
