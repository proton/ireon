// Copyright (C) 2005-2006 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// In addition, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CONFIG_XSD_H
#define CONFIG_XSD_H

#include <xsd/cxx/version.hxx>

#if (XSD_INT_VERSION != 2030000L)
#error XSD runtime version mismatch
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "config_fwd_xsd.h"

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

namespace ireon
{
  namespace ws
  {
    class CWSConfig: public ::xml_schema::type
    {
      public:

      struct _xsd_CWSConfig
      {
        typedef ::xml_schema::type base_;
      };

      // wsID
      // 
      public:
      struct wsID
      {
        typedef ::xml_schema::unsigned_byte type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const wsID::type&
      wsID () const;

      wsID::type&
      wsID ();

      void
      wsID (const wsID::type&);

      // worldCfg
      // 
      public:
      struct worldCfg
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const worldCfg::container&
      worldCfg () const;

      worldCfg::container&
      worldCfg ();

      void
      worldCfg (const worldCfg::type&);

      void
      worldCfg (const worldCfg::container&);

      void
      worldCfg (::std::auto_ptr< worldCfg::type >);

      // playerConnectionsListener
      // 
      public:
      struct playerConnectionsListener
      {
        typedef ::ireon::ws::CPlayerListener type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const playerConnectionsListener::container&
      playerConnectionsListener () const;

      playerConnectionsListener::container&
      playerConnectionsListener ();

      void
      playerConnectionsListener (const playerConnectionsListener::type&);

      void
      playerConnectionsListener (const playerConnectionsListener::container&);

      void
      playerConnectionsListener (::std::auto_ptr< playerConnectionsListener::type >);

      // rsConnection
      // 
      public:
      struct rsConnection
      {
        typedef ::ireon::ws::CRSConnection type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const rsConnection::container&
      rsConnection () const;

      rsConnection::container&
      rsConnection ();

      void
      rsConnection (const rsConnection::type&);

      void
      rsConnection (const rsConnection::container&);

      void
      rsConnection (::std::auto_ptr< rsConnection::type >);

      // db
      // 
      public:
      struct db
      {
        typedef ::ireon::ws::CDBconnection type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const db::type&
      db () const;

      db::type&
      db ();

      void
      db (const db::type&);

      void
      db (::std::auto_ptr< db::type >);

      // resources
      // 
      public:
      struct resources
      {
        typedef ::ireon::ws::CResources type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const resources::container&
      resources () const;

      resources::container&
      resources ();

      void
      resources (const resources::type&);

      void
      resources (const resources::container&);

      void
      resources (::std::auto_ptr< resources::type >);

      // playerDefaultPosition
      // 
      public:
      struct playerDefaultPosition
      {
        typedef ::ireon::ws::CDefaultPosition type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const playerDefaultPosition::container&
      playerDefaultPosition () const;

      playerDefaultPosition::container&
      playerDefaultPosition ();

      void
      playerDefaultPosition (const playerDefaultPosition::type&);

      void
      playerDefaultPosition (const playerDefaultPosition::container&);

      void
      playerDefaultPosition (::std::auto_ptr< playerDefaultPosition::type >);

      // Constructors.
      //
      public:
      CWSConfig (const wsID::type&,
                 const db::type&);

      CWSConfig (const ::xercesc::DOMElement&,
                 ::xml_schema::flags = 0,
                 ::xml_schema::type* = 0);

      CWSConfig (const CWSConfig&,
                 ::xml_schema::flags = 0,
                 ::xml_schema::type* = 0);

      virtual CWSConfig*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< wsID::type > _xsd_wsID_;
      ::xsd::cxx::tree::optional< worldCfg::type > _xsd_worldCfg_;
      ::xsd::cxx::tree::optional< playerConnectionsListener::type > _xsd_playerConnectionsListener_;
      ::xsd::cxx::tree::optional< rsConnection::type > _xsd_rsConnection_;
      ::xsd::cxx::tree::one< db::type > _xsd_db_;
      ::xsd::cxx::tree::optional< resources::type > _xsd_resources_;
      ::xsd::cxx::tree::optional< playerDefaultPosition::type > _xsd_playerDefaultPosition_;
    };

    class CPlayerListener: public ::xml_schema::type
    {
      public:

      struct _xsd_CPlayerListener
      {
        typedef ::xml_schema::type base_;
      };

      // port
      // 
      public:
      struct port
      {
        typedef ::ireon::ws::CPort type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const port::container&
      port () const;

      port::container&
      port ();

      void
      port (const port::type&);

      void
      port (const port::container&);

      void
      port (::std::auto_ptr< port::type >);

      // maxConnections
      // 
      public:
      struct maxConnections
      {
        typedef ::ireon::ws::CConnectionsNumber type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const maxConnections::container&
      maxConnections () const;

      maxConnections::container&
      maxConnections ();

      void
      maxConnections (const maxConnections::type&);

      void
      maxConnections (const maxConnections::container&);

      void
      maxConnections (::std::auto_ptr< maxConnections::type >);

      // Constructors.
      //
      public:
      CPlayerListener ();

      CPlayerListener (const ::xercesc::DOMElement&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      CPlayerListener (const CPlayerListener&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      virtual CPlayerListener*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< port::type > _xsd_port_;
      ::xsd::cxx::tree::optional< maxConnections::type > _xsd_maxConnections_;
    };

    class CRSConnection: public ::xml_schema::type
    {
      public:

      struct _xsd_CRSConnection
      {
        typedef ::xml_schema::type base_;
      };

      // ip
      // 
      public:
      struct ip
      {
        typedef ::ireon::ws::CIPv4Address type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const ip::container&
      ip () const;

      ip::container&
      ip ();

      void
      ip (const ip::type&);

      void
      ip (const ip::container&);

      void
      ip (::std::auto_ptr< ip::type >);

      // port
      // 
      public:
      struct port
      {
        typedef ::ireon::ws::CPort type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const port::container&
      port () const;

      port::container&
      port ();

      void
      port (const port::type&);

      void
      port (const port::container&);

      void
      port (::std::auto_ptr< port::type >);

      // Constructors.
      //
      public:
      CRSConnection ();

      CRSConnection (const ::xercesc::DOMElement&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      CRSConnection (const CRSConnection&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      virtual CRSConnection*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< ip::type > _xsd_ip_;
      ::xsd::cxx::tree::optional< port::type > _xsd_port_;
    };

    class CDBconnection: public ::xml_schema::type
    {
      public:

      struct _xsd_CDBconnection
      {
        typedef ::xml_schema::type base_;
      };

      // ip
      // 
      public:
      struct ip
      {
        typedef ::ireon::ws::CIPv4Address type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const ip::container&
      ip () const;

      ip::container&
      ip ();

      void
      ip (const ip::type&);

      void
      ip (const ip::container&);

      void
      ip (::std::auto_ptr< ip::type >);

      // port
      // 
      public:
      struct port
      {
        typedef ::ireon::ws::CPort type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const port::container&
      port () const;

      port::container&
      port ();

      void
      port (const port::type&);

      void
      port (const port::container&);

      void
      port (::std::auto_ptr< port::type >);

      // login
      // 
      public:
      struct login
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const login::type&
      login () const;

      login::type&
      login ();

      void
      login (const login::type&);

      void
      login (::std::auto_ptr< login::type >);

      // password
      // 
      public:
      struct password
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const password::type&
      password () const;

      password::type&
      password ();

      void
      password (const password::type&);

      void
      password (::std::auto_ptr< password::type >);

      // schema
      // 
      public:
      struct schema
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const schema::container&
      schema () const;

      schema::container&
      schema ();

      void
      schema (const schema::type&);

      void
      schema (const schema::container&);

      void
      schema (::std::auto_ptr< schema::type >);

      // Constructors.
      //
      public:
      CDBconnection (const login::type&,
                     const password::type&);

      CDBconnection (const ::xercesc::DOMElement&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      CDBconnection (const CDBconnection&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      virtual CDBconnection*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< ip::type > _xsd_ip_;
      ::xsd::cxx::tree::optional< port::type > _xsd_port_;
      ::xsd::cxx::tree::one< login::type > _xsd_login_;
      ::xsd::cxx::tree::one< password::type > _xsd_password_;
      ::xsd::cxx::tree::optional< schema::type > _xsd_schema_;
    };

    class CResources: public ::xml_schema::type
    {
      public:

      struct _xsd_CResources
      {
        typedef ::xml_schema::type base_;
      };

      // dir
      // 
      public:
      struct dir
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::sequence< type > container;
        typedef container::iterator iterator;
        typedef container::const_iterator const_iterator;
      };

      const dir::container&
      dir () const;

      dir::container&
      dir ();

      void
      dir (const dir::container&);

      // Constructors.
      //
      public:
      CResources ();

      CResources (const ::xercesc::DOMElement&,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

      CResources (const CResources&,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

      virtual CResources*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::sequence< dir::type > _xsd_dir_;
    };

    class CDefaultPosition: public ::xml_schema::type
    {
      public:

      struct _xsd_CDefaultPosition
      {
        typedef ::xml_schema::type base_;
      };

      // x
      // 
      public:
      struct x
      {
        typedef ::xml_schema::float_ type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const x::type&
      x () const;

      x::type&
      x ();

      void
      x (const x::type&);

      // y
      // 
      public:
      struct y
      {
        typedef ::xml_schema::float_ type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const y::type&
      y () const;

      y::type&
      y ();

      void
      y (const y::type&);

      // Constructors.
      //
      public:
      CDefaultPosition (const x::type&,
                        const y::type&);

      CDefaultPosition (const ::xercesc::DOMElement&,
                        ::xml_schema::flags = 0,
                        ::xml_schema::type* = 0);

      CDefaultPosition (const CDefaultPosition&,
                        ::xml_schema::flags = 0,
                        ::xml_schema::type* = 0);

      virtual CDefaultPosition*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< x::type > _xsd_x_;
      ::xsd::cxx::tree::one< y::type > _xsd_y_;
    };

    class CIPv4Address: public ::xml_schema::string
    {
      public:

      struct _xsd_CIPv4Address
      {
        typedef ::xml_schema::string base_;
      };

      // Constructors.
      //
      public:
      CIPv4Address (const _xsd_CIPv4Address::base_& );

      CIPv4Address (const ::xercesc::DOMElement&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      CIPv4Address (const ::xercesc::DOMAttr&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      CIPv4Address (const ::std::basic_string< char >&,
                    const ::xercesc::DOMElement*,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      CIPv4Address (const CIPv4Address&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      virtual CIPv4Address*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;
    };

    class CPort: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >
    {
      public:

      struct _xsd_CPort
      {
        typedef ::xml_schema::unsigned_short base_;
      };

      // Constructors.
      //
      public:
      CPort (const _xsd_CPort::base_& );

      CPort (const ::xercesc::DOMElement&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

      CPort (const ::xercesc::DOMAttr&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

      CPort (const ::std::basic_string< char >&,
             const ::xercesc::DOMElement*,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

      CPort (const CPort&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

      virtual CPort*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;
    };

    class CConnectionsNumber: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_byte, char, ::xml_schema::simple_type >
    {
      public:

      struct _xsd_CConnectionsNumber
      {
        typedef ::xml_schema::unsigned_byte base_;
      };

      // Constructors.
      //
      public:
      CConnectionsNumber (const _xsd_CConnectionsNumber::base_& );

      CConnectionsNumber (const ::xercesc::DOMElement&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      CConnectionsNumber (const ::xercesc::DOMAttr&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      CConnectionsNumber (const ::std::basic_string< char >&,
                          const ::xercesc::DOMElement*,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      CConnectionsNumber (const CConnectionsNumber&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      virtual CConnectionsNumber*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;
    };
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMInputSource.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

#include <xsd/cxx/tree/parsing.hxx>

namespace ireon
{
  namespace ws
  {
    // Read from a URI or a local file.
    //

    ::std::auto_ptr< ::ireon::ws::CWSConfig >
    config (const ::std::basic_string< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::ws::CWSConfig >
    config (const ::std::basic_string< char >&,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::ws::CWSConfig >
    config (const ::std::basic_string< char >&,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    // Read from std::istream.
    //

    ::std::auto_ptr< ::ireon::ws::CWSConfig >
    config (::std::istream&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::ws::CWSConfig >
    config (::std::istream&,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::ws::CWSConfig >
    config (::std::istream&,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    ::std::auto_ptr< ::ireon::ws::CWSConfig >
    config (::std::istream&,
            const ::std::basic_string< char >& id,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::ws::CWSConfig >
    config (::std::istream&,
            const ::std::basic_string< char >& id,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::ws::CWSConfig >
    config (::std::istream&,
            const ::std::basic_string< char >& id,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    // Read from InputSource.
    //

    ::std::auto_ptr< ::ireon::ws::CWSConfig >
    config (const ::xercesc::DOMInputSource&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::ws::CWSConfig >
    config (const ::xercesc::DOMInputSource&,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::ws::CWSConfig >
    config (const ::xercesc::DOMInputSource&,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    // Read from DOM.
    //

    ::std::auto_ptr< ::ireon::ws::CWSConfig >
    config (const ::xercesc::DOMDocument&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());
  }
}

#include <iosfwd> // std::ostream&

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>
#include <xsd/cxx/tree/serialization.hxx>

namespace ireon
{
  namespace ws
  {
    // Serialize to an existing DOM instance.
    //
    void
    config (::xercesc::DOMDocument&,
            const ::ireon::ws::CWSConfig&,
            ::xml_schema::flags = 0);


    // Serialize to a new DOM instance.
    //
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    config (const ::ireon::ws::CWSConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xml_schema::flags = 0);


    // Serialize to XMLFormatTarget.
    //
    void
    config (::xercesc::XMLFormatTarget&,
            const ::ireon::ws::CWSConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


    void
    config (::xercesc::XMLFormatTarget&,
            const ::ireon::ws::CWSConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xsd::cxx::xml::error_handler< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);

    void
    config (::xercesc::XMLFormatTarget&,
            const ::ireon::ws::CWSConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xercesc::DOMErrorHandler&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


    // Serialize to std::ostream.
    //
    void
    config (::std::ostream&,
            const ::ireon::ws::CWSConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


    void
    config (::std::ostream&,
            const ::ireon::ws::CWSConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xsd::cxx::xml::error_handler< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);

    void
    config (::std::ostream&,
            const ::ireon::ws::CWSConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xercesc::DOMErrorHandler&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


    void
    operator<< (::xercesc::DOMElement&,
                const CWSConfig&);

    void
    operator<< (::xercesc::DOMElement&,
                const CPlayerListener&);

    void
    operator<< (::xercesc::DOMElement&,
                const CRSConnection&);

    void
    operator<< (::xercesc::DOMElement&,
                const CDBconnection&);

    void
    operator<< (::xercesc::DOMElement&,
                const CResources&);

    void
    operator<< (::xercesc::DOMElement&,
                const CDefaultPosition&);

    void
    operator<< (::xercesc::DOMElement&,
                const CIPv4Address&);

    void
    operator<< (::xercesc::DOMAttr&,
                const CIPv4Address&);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                const CIPv4Address&);

    void
    operator<< (::xercesc::DOMElement&,
                const CPort&);

    void
    operator<< (::xercesc::DOMAttr&,
                const CPort&);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                const CPort&);

    void
    operator<< (::xercesc::DOMElement&,
                const CConnectionsNumber&);

    void
    operator<< (::xercesc::DOMAttr&,
                const CConnectionsNumber&);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                const CConnectionsNumber&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CONFIG_XSD_H
