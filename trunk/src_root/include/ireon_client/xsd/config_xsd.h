// Copyright (C) 2005-2006 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// In addition, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CONFIG_XSD_H
#define CONFIG_XSD_H

#include <xsd/cxx/version.hxx>

#if (XSD_INT_VERSION != 2030000L)
#error XSD runtime version mismatch
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "config_fwd_xsd.h"

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

namespace ireon
{
  namespace client
  {
    class CPCConfig: public ::xml_schema::type
    {
      public:

      struct _xsd_CPCConfig
      {
        typedef ::xml_schema::type base_;
      };

      // net
      // 
      public:
      struct net
      {
        typedef ::ireon::client::CNet type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const net::container&
      net () const;

      net::container&
      net ();

      void
      net (const net::type&);

      void
      net (const net::container&);

      void
      net (::std::auto_ptr< net::type >);

      // resources
      // 
      public:
      struct resources
      {
        typedef ::ireon::client::CResources type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const resources::container&
      resources () const;

      resources::container&
      resources ();

      void
      resources (const resources::type&);

      void
      resources (const resources::container&);

      void
      resources (::std::auto_ptr< resources::type >);

      // world
      // 
      public:
      struct world
      {
        typedef ::ireon::client::CWorldSettings type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const world::container&
      world () const;

      world::container&
      world ();

      void
      world (const world::type&);

      void
      world (const world::container&);

      void
      world (::std::auto_ptr< world::type >);

      // profile
      // 
      public:
      struct profile
      {
        typedef ::ireon::client::CProfile type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const profile::container&
      profile () const;

      profile::container&
      profile ();

      void
      profile (const profile::type&);

      void
      profile (const profile::container&);

      void
      profile (::std::auto_ptr< profile::type >);

      // _interface
      // 
      public:
      struct _interface
      {
        typedef ::ireon::client::CInterfaceSettings type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const _interface::container&
      _interface () const;

      _interface::container&
      _interface ();

      void
      _interface (const _interface::type&);

      void
      _interface (const _interface::container&);

      void
      _interface (::std::auto_ptr< _interface::type >);

      // Constructors.
      //
      public:
      CPCConfig ();

      CPCConfig (const ::xercesc::DOMElement&,
                 ::xml_schema::flags = 0,
                 ::xml_schema::type* = 0);

      CPCConfig (const CPCConfig&,
                 ::xml_schema::flags = 0,
                 ::xml_schema::type* = 0);

      virtual CPCConfig*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< net::type > _xsd_net_;
      ::xsd::cxx::tree::optional< resources::type > _xsd_resources_;
      ::xsd::cxx::tree::optional< world::type > _xsd_world_;
      ::xsd::cxx::tree::optional< profile::type > _xsd_profile_;
      ::xsd::cxx::tree::optional< _interface::type > _xsd__interface_;
    };

    class CNet: public ::xml_schema::type
    {
      public:

      struct _xsd_CNet
      {
        typedef ::xml_schema::type base_;
      };

      // rootServer
      // 
      public:
      struct rootServer
      {
        typedef ::ireon::client::CRootServer type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const rootServer::container&
      rootServer () const;

      rootServer::container&
      rootServer ();

      void
      rootServer (const rootServer::type&);

      void
      rootServer (const rootServer::container&);

      void
      rootServer (::std::auto_ptr< rootServer::type >);

      // worldServer
      // 
      public:
      struct worldServer
      {
        typedef ::ireon::client::CWorldServer type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const worldServer::container&
      worldServer () const;

      worldServer::container&
      worldServer ();

      void
      worldServer (const worldServer::type&);

      void
      worldServer (const worldServer::container&);

      void
      worldServer (::std::auto_ptr< worldServer::type >);

      // Constructors.
      //
      public:
      CNet ();

      CNet (const ::xercesc::DOMElement&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

      CNet (const CNet&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

      virtual CNet*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< rootServer::type > _xsd_rootServer_;
      ::xsd::cxx::tree::optional< worldServer::type > _xsd_worldServer_;
    };

    class CRootServer: public ::xml_schema::type
    {
      public:

      struct _xsd_CRootServer
      {
        typedef ::xml_schema::type base_;
      };

      // ip
      // 
      public:
      struct ip
      {
        typedef ::ireon::client::CIPv4Address type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const ip::container&
      ip () const;

      ip::container&
      ip ();

      void
      ip (const ip::type&);

      void
      ip (const ip::container&);

      void
      ip (::std::auto_ptr< ip::type >);

      // port
      // 
      public:
      struct port
      {
        typedef ::ireon::client::CPort type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const port::container&
      port () const;

      port::container&
      port ();

      void
      port (const port::type&);

      void
      port (const port::container&);

      void
      port (::std::auto_ptr< port::type >);

      // Constructors.
      //
      public:
      CRootServer ();

      CRootServer (const ::xercesc::DOMElement&,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

      CRootServer (const CRootServer&,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

      virtual CRootServer*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< ip::type > _xsd_ip_;
      ::xsd::cxx::tree::optional< port::type > _xsd_port_;
    };

    class CWorldServer: public ::xml_schema::type
    {
      public:

      struct _xsd_CWorldServer
      {
        typedef ::xml_schema::type base_;
      };

      // port
      // 
      public:
      struct port
      {
        typedef ::ireon::client::CPort type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const port::container&
      port () const;

      port::container&
      port ();

      void
      port (const port::type&);

      void
      port (const port::container&);

      void
      port (::std::auto_ptr< port::type >);

      // Constructors.
      //
      public:
      CWorldServer ();

      CWorldServer (const ::xercesc::DOMElement&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      CWorldServer (const CWorldServer&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      virtual CWorldServer*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< port::type > _xsd_port_;
    };

    class CIPv4Address: public ::xml_schema::string
    {
      public:

      struct _xsd_CIPv4Address
      {
        typedef ::xml_schema::string base_;
      };

      // Constructors.
      //
      public:
      CIPv4Address (const _xsd_CIPv4Address::base_& );

      CIPv4Address (const ::xercesc::DOMElement&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      CIPv4Address (const ::xercesc::DOMAttr&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      CIPv4Address (const ::std::basic_string< char >&,
                    const ::xercesc::DOMElement*,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      CIPv4Address (const CIPv4Address&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      virtual CIPv4Address*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;
    };

    class CPort: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_short, char, ::xml_schema::simple_type >
    {
      public:

      struct _xsd_CPort
      {
        typedef ::xml_schema::unsigned_short base_;
      };

      // Constructors.
      //
      public:
      CPort (const _xsd_CPort::base_& );

      CPort (const ::xercesc::DOMElement&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

      CPort (const ::xercesc::DOMAttr&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

      CPort (const ::std::basic_string< char >&,
             const ::xercesc::DOMElement*,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

      CPort (const CPort&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

      virtual CPort*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;
    };

    class CWorldSettings: public ::xml_schema::type
    {
      public:

      struct _xsd_CWorldSettings
      {
        typedef ::xml_schema::type base_;
      };

      // light
      // 
      public:
      struct light
      {
        typedef ::ireon::client::CLightSettings type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const light::container&
      light () const;

      light::container&
      light ();

      void
      light (const light::type&);

      void
      light (const light::container&);

      void
      light (::std::auto_ptr< light::type >);

      // worldPath
      // 
      public:
      struct worldPath
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const worldPath::container&
      worldPath () const;

      worldPath::container&
      worldPath ();

      void
      worldPath (const worldPath::type&);

      void
      worldPath (const worldPath::container&);

      void
      worldPath (::std::auto_ptr< worldPath::type >);

      // proto
      // 
      public:
      struct proto
      {
        typedef ::ireon::client::CProtoSettings type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const proto::container&
      proto () const;

      proto::container&
      proto ();

      void
      proto (const proto::type&);

      void
      proto (const proto::container&);

      void
      proto (::std::auto_ptr< proto::type >);

      // dataPath
      // 
      public:
      struct dataPath
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const dataPath::container&
      dataPath () const;

      dataPath::container&
      dataPath ();

      void
      dataPath (const dataPath::type&);

      void
      dataPath (const dataPath::container&);

      void
      dataPath (::std::auto_ptr< dataPath::type >);

      // player
      // 
      public:
      struct player
      {
        typedef ::ireon::client::CPlayerSettings type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const player::container&
      player () const;

      player::container&
      player ();

      void
      player (const player::type&);

      void
      player (const player::container&);

      void
      player (::std::auto_ptr< player::type >);

      // Constructors.
      //
      public:
      CWorldSettings ();

      CWorldSettings (const ::xercesc::DOMElement&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

      CWorldSettings (const CWorldSettings&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

      virtual CWorldSettings*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< light::type > _xsd_light_;
      ::xsd::cxx::tree::optional< worldPath::type > _xsd_worldPath_;
      ::xsd::cxx::tree::optional< proto::type > _xsd_proto_;
      ::xsd::cxx::tree::optional< dataPath::type > _xsd_dataPath_;
      ::xsd::cxx::tree::optional< player::type > _xsd_player_;
    };

    class CProtoSettings: public ::xml_schema::type
    {
      public:

      struct _xsd_CProtoSettings
      {
        typedef ::xml_schema::type base_;
      };

      // directory
      // 
      public:
      struct directory
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const directory::container&
      directory () const;

      directory::container&
      directory ();

      void
      directory (const directory::type&);

      void
      directory (const directory::container&);

      void
      directory (::std::auto_ptr< directory::type >);

      // loadAll
      // 
      public:
      struct loadAll
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const loadAll::container&
      loadAll () const;

      loadAll::container&
      loadAll ();

      void
      loadAll (const loadAll::type&);

      void
      loadAll (const loadAll::container&);

      // Constructors.
      //
      public:
      CProtoSettings ();

      CProtoSettings (const ::xercesc::DOMElement&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

      CProtoSettings (const CProtoSettings&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

      virtual CProtoSettings*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< directory::type > _xsd_directory_;
      ::xsd::cxx::tree::optional< loadAll::type > _xsd_loadAll_;
    };

    class CPlayerSettings: public ::xml_schema::type
    {
      public:

      struct _xsd_CPlayerSettings
      {
        typedef ::xml_schema::type base_;
      };

      // mesh
      // 
      public:
      struct mesh
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const mesh::container&
      mesh () const;

      mesh::container&
      mesh ();

      void
      mesh (const mesh::type&);

      void
      mesh (const mesh::container&);

      void
      mesh (::std::auto_ptr< mesh::type >);

      // Constructors.
      //
      public:
      CPlayerSettings ();

      CPlayerSettings (const ::xercesc::DOMElement&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      CPlayerSettings (const CPlayerSettings&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      virtual CPlayerSettings*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< mesh::type > _xsd_mesh_;
    };

    class CLightSettings: public ::xml_schema::type
    {
      public:

      struct _xsd_CLightSettings
      {
        typedef ::xml_schema::type base_;
      };

      // main
      // 
      public:
      struct main
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const main::type&
      main () const;

      main::type&
      main ();

      void
      main (const main::type&);

      void
      main (::std::auto_ptr< main::type >);

      // ambient
      // 
      public:
      struct ambient
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const ambient::type&
      ambient () const;

      ambient::type&
      ambient ();

      void
      ambient (const ambient::type&);

      void
      ambient (::std::auto_ptr< ambient::type >);

      // shadows
      // 
      public:
      struct shadows
      {
        typedef ::ireon::client::CShadowSettings type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const shadows::container&
      shadows () const;

      shadows::container&
      shadows ();

      void
      shadows (const shadows::type&);

      void
      shadows (const shadows::container&);

      void
      shadows (::std::auto_ptr< shadows::type >);

      // enabled
      // 
      public:
      struct enabled
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const enabled::type&
      enabled () const;

      enabled::type&
      enabled ();

      void
      enabled (const enabled::type&);

      // Constructors.
      //
      public:
      CLightSettings (const main::type&,
                      const ambient::type&);

      CLightSettings (const ::xercesc::DOMElement&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

      CLightSettings (const CLightSettings&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

      virtual CLightSettings*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< main::type > _xsd_main_;
      ::xsd::cxx::tree::one< ambient::type > _xsd_ambient_;
      ::xsd::cxx::tree::optional< shadows::type > _xsd_shadows_;
      ::xsd::cxx::tree::one< enabled::type > _xsd_enabled_;
    };

    class CShadowSettings: public ::xml_schema::type
    {
      public:

      struct _xsd_CShadowSettings
      {
        typedef ::xml_schema::type base_;
      };

      // colour
      // 
      public:
      struct colour
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const colour::type&
      colour () const;

      colour::type&
      colour ();

      void
      colour (const colour::type&);

      void
      colour (::std::auto_ptr< colour::type >);

      // enabled
      // 
      public:
      struct enabled
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const enabled::type&
      enabled () const;

      enabled::type&
      enabled ();

      void
      enabled (const enabled::type&);

      // Constructors.
      //
      public:
      CShadowSettings (const colour::type&);

      CShadowSettings (const ::xercesc::DOMElement&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      CShadowSettings (const CShadowSettings&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      virtual CShadowSettings*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< colour::type > _xsd_colour_;
      ::xsd::cxx::tree::one< enabled::type > _xsd_enabled_;
    };

    class CProfile: public ::xml_schema::type
    {
      public:

      struct _xsd_CProfile
      {
        typedef ::xml_schema::type base_;
      };

      // login
      // 
      public:
      struct login
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const login::type&
      login () const;

      login::type&
      login ();

      void
      login (const login::type&);

      void
      login (::std::auto_ptr< login::type >);

      // password
      // 
      public:
      struct password
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const password::type&
      password () const;

      password::type&
      password ();

      void
      password (const password::type&);

      void
      password (::std::auto_ptr< password::type >);

      // registration
      // 
      public:
      struct registration
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const registration::container&
      registration () const;

      registration::container&
      registration ();

      void
      registration (const registration::type&);

      void
      registration (const registration::container&);

      // Constructors.
      //
      public:
      CProfile (const login::type&,
                const password::type&);

      CProfile (const ::xercesc::DOMElement&,
                ::xml_schema::flags = 0,
                ::xml_schema::type* = 0);

      CProfile (const CProfile&,
                ::xml_schema::flags = 0,
                ::xml_schema::type* = 0);

      virtual CProfile*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< login::type > _xsd_login_;
      ::xsd::cxx::tree::one< password::type > _xsd_password_;
      ::xsd::cxx::tree::optional< registration::type > _xsd_registration_;
    };

    class CInterfaceSettings: public ::xml_schema::type
    {
      public:

      struct _xsd_CInterfaceSettings
      {
        typedef ::xml_schema::type base_;
      };

      // dir
      // 
      public:
      struct dir
      {
        typedef ::xml_schema::normalized_string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const dir::container&
      dir () const;

      dir::container&
      dir ();

      void
      dir (const dir::type&);

      void
      dir (const dir::container&);

      void
      dir (::std::auto_ptr< dir::type >);

      // symbols
      // 
      public:
      struct symbols
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;

        static const type&
        default_value ();

        private:
        static const type default_value_;
      };

      const symbols::container&
      symbols () const;

      symbols::container&
      symbols ();

      void
      symbols (const symbols::type&);

      void
      symbols (const symbols::container&);

      void
      symbols (::std::auto_ptr< symbols::type >);

      // script
      // 
      public:
      struct script
      {
        typedef ::ireon::client::CResourceItem type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::sequence< type > container;
        typedef container::iterator iterator;
        typedef container::const_iterator const_iterator;
      };

      const script::container&
      script () const;

      script::container&
      script ();

      void
      script (const script::container&);

      // Constructors.
      //
      public:
      CInterfaceSettings ();

      CInterfaceSettings (const ::xercesc::DOMElement&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      CInterfaceSettings (const CInterfaceSettings&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      virtual CInterfaceSettings*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< dir::type > _xsd_dir_;
      ::xsd::cxx::tree::optional< symbols::type > _xsd_symbols_;
      ::xsd::cxx::tree::sequence< script::type > _xsd_script_;
    };

    class CResources: public ::xml_schema::type
    {
      public:

      struct _xsd_CResources
      {
        typedef ::xml_schema::type base_;
      };

      // resource
      // 
      public:
      struct resource
      {
        typedef ::ireon::client::CResourceItem type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::sequence< type > container;
        typedef container::iterator iterator;
        typedef container::const_iterator const_iterator;
      };

      const resource::container&
      resource () const;

      resource::container&
      resource ();

      void
      resource (const resource::container&);

      // Constructors.
      //
      public:
      CResources ();

      CResources (const ::xercesc::DOMElement&,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

      CResources (const CResources&,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

      virtual CResources*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::sequence< resource::type > _xsd_resource_;
    };

    class CResourceItem: public ::xml_schema::string
    {
      public:

      struct _xsd_CResourceItem
      {
        typedef ::xml_schema::string base_;
      };

      // Workaround for g++ bug# 23206.
      //
      public:
      struct type;

      // category
      // 
      public:
      struct category
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const category::type&
      category () const;

      category::type&
      category ();

      void
      category (const category::type&);

      void
      category (::std::auto_ptr< category::type >);

      // type
      // 
      public:
      struct type
      {
        typedef ::xml_schema::string type_;
        typedef ::xsd::cxx::tree::traits< type_, char > traits;
      };

      const type::type_&
      type () const;

      type::type_&
      type ();

      void
      type (const type::type_&);

      void
      type (::std::auto_ptr< type::type_ >);

      // Constructors.
      //
      public:
      CResourceItem (const _xsd_CResourceItem::base_& ,
                     const category::type&,
                     const type::type_&);

      CResourceItem (const ::xercesc::DOMElement&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      CResourceItem (const CResourceItem&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      virtual CResourceItem*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< category::type > _xsd_category_;
      ::xsd::cxx::tree::one< type::type_ > _xsd_type_;
    };
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMInputSource.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

#include <xsd/cxx/tree/parsing.hxx>

namespace ireon
{
  namespace client
  {
    // Read from a URI or a local file.
    //

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (const ::std::basic_string< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (const ::std::basic_string< char >&,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (const ::std::basic_string< char >&,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    // Read from std::istream.
    //

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (::std::istream&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (::std::istream&,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (::std::istream&,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (::std::istream&,
            const ::std::basic_string< char >& id,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (::std::istream&,
            const ::std::basic_string< char >& id,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (::std::istream&,
            const ::std::basic_string< char >& id,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    // Read from InputSource.
    //

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (const ::xercesc::DOMInputSource&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (const ::xercesc::DOMInputSource&,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (const ::xercesc::DOMInputSource&,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    // Read from DOM.
    //

    ::std::auto_ptr< ::ireon::client::CPCConfig >
    config (const ::xercesc::DOMDocument&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());
  }
}

#include <iosfwd> // std::ostream&

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>
#include <xsd/cxx/tree/serialization.hxx>

namespace ireon
{
  namespace client
  {
    // Serialize to an existing DOM instance.
    //
    void
    config (::xercesc::DOMDocument&,
            const ::ireon::client::CPCConfig&,
            ::xml_schema::flags = 0);


    // Serialize to a new DOM instance.
    //
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    config (const ::ireon::client::CPCConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xml_schema::flags = 0);


    // Serialize to XMLFormatTarget.
    //
    void
    config (::xercesc::XMLFormatTarget&,
            const ::ireon::client::CPCConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


    void
    config (::xercesc::XMLFormatTarget&,
            const ::ireon::client::CPCConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xsd::cxx::xml::error_handler< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);

    void
    config (::xercesc::XMLFormatTarget&,
            const ::ireon::client::CPCConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xercesc::DOMErrorHandler&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


    // Serialize to std::ostream.
    //
    void
    config (::std::ostream&,
            const ::ireon::client::CPCConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


    void
    config (::std::ostream&,
            const ::ireon::client::CPCConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xsd::cxx::xml::error_handler< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);

    void
    config (::std::ostream&,
            const ::ireon::client::CPCConfig&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xercesc::DOMErrorHandler&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


    void
    operator<< (::xercesc::DOMElement&,
                const CPCConfig&);

    void
    operator<< (::xercesc::DOMElement&,
                const CNet&);

    void
    operator<< (::xercesc::DOMElement&,
                const CRootServer&);

    void
    operator<< (::xercesc::DOMElement&,
                const CWorldServer&);

    void
    operator<< (::xercesc::DOMElement&,
                const CIPv4Address&);

    void
    operator<< (::xercesc::DOMAttr&,
                const CIPv4Address&);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                const CIPv4Address&);

    void
    operator<< (::xercesc::DOMElement&,
                const CPort&);

    void
    operator<< (::xercesc::DOMAttr&,
                const CPort&);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                const CPort&);

    void
    operator<< (::xercesc::DOMElement&,
                const CWorldSettings&);

    void
    operator<< (::xercesc::DOMElement&,
                const CProtoSettings&);

    void
    operator<< (::xercesc::DOMElement&,
                const CPlayerSettings&);

    void
    operator<< (::xercesc::DOMElement&,
                const CLightSettings&);

    void
    operator<< (::xercesc::DOMElement&,
                const CShadowSettings&);

    void
    operator<< (::xercesc::DOMElement&,
                const CProfile&);

    void
    operator<< (::xercesc::DOMElement&,
                const CInterfaceSettings&);

    void
    operator<< (::xercesc::DOMElement&,
                const CResources&);

    void
    operator<< (::xercesc::DOMElement&,
                const CResourceItem&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CONFIG_XSD_H
